{
  "address": "0xED5e562aa5fEB2823250571DD0A97891E2b8c6Ee",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "member",
          "type": "address"
        }
      ],
      "name": "MemberActivated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "member",
          "type": "address"
        }
      ],
      "name": "MemberAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "member",
          "type": "address"
        }
      ],
      "name": "MemberDeactivated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "member",
          "type": "address"
        }
      ],
      "name": "MemberRemoved",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "member",
          "type": "address"
        }
      ],
      "name": "activateMember",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address payable",
          "name": "member",
          "type": "address"
        }
      ],
      "name": "addMember",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address payable",
          "name": "member",
          "type": "address"
        }
      ],
      "name": "deactivateMember",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "member",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "cursor",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "perPage",
          "type": "uint256"
        }
      ],
      "name": "fastMemberships",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "candidate",
          "type": "address"
        }
      ],
      "name": "isMember",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "member",
          "type": "address"
        }
      ],
      "name": "isMemberActive",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "member",
          "type": "address"
        }
      ],
      "name": "memberAddedToFast",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "memberCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "member",
          "type": "address"
        }
      ],
      "name": "memberRemovedFromFast",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "cursor",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "perPage",
          "type": "uint256"
        }
      ],
      "name": "paginateMembers",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "member",
          "type": "address"
        }
      ],
      "name": "removeMember",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xfd4a6600d73f26e7e5b5f874877b6077777b44ad6342d50c17d6384f53a97c99",
  "receipt": {
    "to": "0x6DF2D25d8C6FD680730ee658b530A05a99BB769a",
    "from": "0x717634cfe06FFAB2CEAA7fcf1b9019813f4B25FE",
    "contractAddress": null,
    "transactionIndex": 0,
    "gasUsed": "2071653",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x4f9e35c6040c9758584a0b2632efe081f36806071495da348cf97f52f4ecbd31",
    "transactionHash": "0xfd4a6600d73f26e7e5b5f874877b6077777b44ad6342d50c17d6384f53a97c99",
    "logs": [],
    "blockNumber": 140740,
    "cumulativeGasUsed": "2071653",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 3,
  "solcInputHash": "317f6c89c95482d958ebb47efbbf9a77",
  "metadata": "{\"compiler\":{\"version\":\"0.8.4+commit.c7e474f2\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"MemberActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"MemberAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"MemberDeactivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"MemberRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"activateMember\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"addMember\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"deactivateMember\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perPage\",\"type\":\"uint256\"}],\"name\":\"fastMemberships\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"}],\"name\":\"isMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"isMemberActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"memberAddedToFast\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"memberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"memberRemovedFromFast\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perPage\",\"type\":\"uint256\"}],\"name\":\"paginateMembers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"removeMember\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"The Exchange Access facet is in charge of keeping track of exchange members.\",\"kind\":\"dev\",\"methods\":{\"activateMember(address)\":{\"details\":\"Activates a member at the Exchange level.\",\"params\":{\"member\":\"The member to remove from the deactivation member set.\"}},\"addMember(address)\":{\"details\":\"Adds a member to this Exchange member list.\",\"params\":{\"member\":\"is the address of the member to be added.\"}},\"deactivateMember(address)\":{\"details\":\"Deactivates a member at the Exchange level.\",\"params\":{\"member\":\"The member to add to the deactivation member set.\"}},\"fastMemberships(address,uint256,uint256)\":{\"details\":\"Allows to query FAST memberships for a given member address.\",\"params\":{\"cursor\":\"The index at which to start.\",\"member\":\"Is the address to check.\",\"perPage\":\"How many records should be returned at most.\"}},\"isMember(address)\":{\"details\":\"Queries whether a given address is a member of this Exchange or not.\",\"params\":{\"candidate\":\"is the address to test.\"},\"returns\":{\"_0\":\"A `boolean` flag.\"}},\"isMemberActive(address)\":{\"details\":\"Given a member returns it's activation status.\",\"params\":{\"member\":\"The member to check activation status on.\"}},\"memberAddedToFast(address)\":{\"details\":\"Callback from FAST contracts allowing the Exchange contract to keep track of FAST memberships.\",\"params\":{\"member\":\"The member for which a new FAST membership has been added.\"}},\"memberCount()\":{\"details\":\"Counts the numbers of members present in this Exchange.\",\"returns\":{\"_0\":\"The number of members in this exchange.\"}},\"memberRemovedFromFast(address)\":{\"details\":\"Callback from FAST contracts allowing the Exchange contract to keep track of FAST memberships.\",\"params\":{\"member\":\"The member for which a FAST membership has been removed.\"}},\"paginateMembers(uint256,uint256)\":{\"details\":\"Paginates the members of this Exchange based on a starting cursor and a number of records per page.\",\"params\":{\"cursor\":\"is the index at which to start.\",\"perPage\":\"is how many records should be returned at most.\"},\"returns\":{\"_0\":\"A `address[]` list of values at most `perPage` big.\",\"_1\":\"A `uint256` index to the next page.\"}},\"removeMember(address)\":{\"details\":\"Removes a member from this Exchange.\",\"params\":{\"member\":\"is the address of the member to be removed.\"}}},\"title\":\"The Exchange Smart Contract.\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"addMember(address)\":{\"notice\":\"Requires that the caller is a member of the linked SPC.Emits a `IHasMembers.MemberAdded` event.\"},\"removeMember(address)\":{\"notice\":\"Requires that the caller is a member of the linked SPC.Emits a `IHasMembers.MemberRemoved` event.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/exchange/ExchangeAccessFacet.sol\":\"ExchangeAccessFacet\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/exchange/ExchangeAccessFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport '../spc/SpcTopFacet.sol';\\nimport '../interfaces/IHasMembers.sol';\\nimport '../interfaces/IHasActiveMembers.sol';\\nimport './lib/LibExchangeAccess.sol';\\nimport './lib/AExchangeFacet.sol';\\n\\n\\n/** @title The Exchange Smart Contract.\\n *  @dev The Exchange Access facet is in charge of keeping track of exchange members.\\n */\\ncontract ExchangeAccessFacet is AExchangeFacet, IHasMembers, IHasActiveMembers {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  // Membership management.\\n\\n  /** @dev Queries whether a given address is a member of this Exchange or not.\\n   *  @param candidate is the address to test.\\n   *  @return A `boolean` flag.\\n   */\\n  function isMember(address candidate)\\n      external override view returns(bool) {\\n    return LibExchangeAccess.data().memberSet.contains(candidate);\\n  }\\n\\n  /** @dev Counts the numbers of members present in this Exchange.\\n   *  @return The number of members in this exchange.\\n   */\\n  function memberCount()\\n      external override view returns(uint256) {\\n    return LibExchangeAccess.data().memberSet.values.length;\\n  }\\n\\n  /** @dev Paginates the members of this Exchange based on a starting cursor and a number of records per page.\\n   *  @param cursor is the index at which to start.\\n   *  @param perPage is how many records should be returned at most.\\n   *  @return A `address[]` list of values at most `perPage` big.\\n   *  @return A `uint256` index to the next page.\\n   */\\n  function paginateMembers(uint256 cursor, uint256 perPage)\\n      external override view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibExchangeAccess.data().memberSet.values, cursor, perPage);\\n  }\\n\\n  /** @dev Adds a member to this Exchange member list.\\n   *  @param member is the address of the member to be added.\\n   *  @notice Requires that the caller is a member of the linked SPC.\\n   *  @notice Emits a `IHasMembers.MemberAdded` event.\\n   */\\n  function addMember(address payable member)\\n      external override\\n      onlySpcMember {\\n    // Add the member to our list.\\n    LibExchangeAccess.data().memberSet.add(member, false);\\n    // Emit!\\n    emit MemberAdded(member);\\n  }\\n\\n  /** @dev Removes a member from this Exchange.\\n   *  @param member is the address of the member to be removed.\\n   *  @notice Requires that the caller is a member of the linked SPC.\\n   *  @notice Emits a `IHasMembers.MemberRemoved` event.\\n   */\\n  function removeMember(address member)\\n      external override\\n      onlySpcMember {\\n    LibExchangeAccess.Data storage s = LibExchangeAccess.data();\\n    // Ensure that member doesn't have any FAST membership.\\n    require(s.fastMemberships[member].values.length == 0, LibConstants.REQUIRES_NO_FAST_MEMBERSHIPS);\\n    // Remove member.\\n    s.memberSet.remove(member, false);\\n    // Emit!\\n    emit MemberRemoved(member);\\n  }\\n\\n  /** @dev Allows to query FAST memberships for a given member address.\\n   *  @param member Is the address to check.\\n   *  @param cursor The index at which to start.\\n   *  @param perPage How many records should be returned at most.\\n   */\\n  function fastMemberships(address member, uint256 cursor, uint256 perPage)\\n      external view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibExchangeAccess.data().fastMemberships[member].values, cursor, perPage);\\n  }\\n\\n  /** @dev Callback from FAST contracts allowing the Exchange contract to keep track of FAST memberships.\\n   *  @param member The member for which a new FAST membership has been added.\\n   */\\n  function memberAddedToFast(address member) \\n      external {\\n    // Verify that the given address is in fact a registered FAST contract.\\n    require(\\n      SpcTopFacet(LibExchange.data().spc).isFastRegistered(msg.sender),\\n      LibConstants.REQUIRES_FAST_CONTRACT_CALLER\\n    );\\n    // Keep track of the member's FAST membership.\\n    LibAddressSet.Data storage memberFasts = LibExchangeAccess.data().fastMemberships[member];\\n    memberFasts.add(msg.sender, false);\\n  }\\n\\n  /** @dev Callback from FAST contracts allowing the Exchange contract to keep track of FAST memberships.\\n   *  @param member The member for which a FAST membership has been removed.\\n   */\\n  function memberRemovedFromFast(address member)\\n      external {\\n    require(\\n      SpcTopFacet(LibExchange.data().spc).isFastRegistered(msg.sender),\\n      LibConstants.REQUIRES_FAST_CONTRACT_CALLER\\n    );\\n    // Remove the tracked membership.\\n    LibAddressSet.Data storage memberFasts = LibExchangeAccess.data().fastMemberships[member];\\n    memberFasts.remove(msg.sender, false);\\n  }\\n\\n  /** @dev Given a member returns it's activation status.\\n   *  @param member The member to check activation status on.\\n   */\\n  function isMemberActive(address member) external override view returns(bool) {\\n    return !LibExchangeAccess.data().deactivatedMemberSet.contains(member);\\n  }\\n\\n  /** @dev Activates a member at the Exchange level.\\n   *  @param member The member to remove from the deactivation member set.\\n   */\\n  function activateMember(address member)\\n    external\\n    override\\n    onlySpcMember\\n    onlyMember(member) {\\n    // Guard against attempting to activate an already active member.\\n    require(\\n      !this.isMemberActive(member),\\n      LibConstants.REQUIRES_EXCHANGE_DEACTIVATED_MEMBER\\n    );\\n\\n    // Remove the member from the deactivated members list.\\n    LibExchangeAccess.data().deactivatedMemberSet.remove(member, false);\\n\\n    // Emit!\\n    emit MemberActivated(member);\\n  }\\n\\n  /** @dev Deactivates a member at the Exchange level.\\n   *  @param member The member to add to the deactivation member set.\\n   */\\n  function deactivateMember(address payable member)\\n    external\\n    override\\n    onlySpcMember\\n    onlyMember(member) {\\n    // Guard against attempting to deactivate an already deactivated member.\\n    require(\\n      this.isMemberActive(member),\\n      LibConstants.REQUIRES_EXCHANGE_ACTIVE_MEMBER\\n    );\\n\\n    // Add the member to the deactivated members list.\\n    LibExchangeAccess.data().deactivatedMemberSet.add(member, false);\\n\\n    // Emit!\\n    emit MemberDeactivated(member);\\n  }\\n}\\n\",\"keccak256\":\"0x27770d3b210cecb8d345f5b1aa9d3b7f7eedc7a59f0dfbaae0e154a93dc0639d\",\"license\":\"MIT\"},\"contracts/exchange/lib/AExchangeFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibConstants.sol';\\nimport '../../lib/LibAddressSet.sol';\\nimport '../lib/LibExchange.sol';\\nimport '../lib/LibExchangeAccess.sol';\\nimport '../../interfaces/IERC173.sol';\\nimport '../../interfaces/IHasMembers.sol';\\nimport './IExchangeEvents.sol';\\n\\n\\n/**\\n* @dev This contract is a group of modifiers that can be used by any Exchange facets to guard against\\n*       certain permissions.\\n*/\\nabstract contract AExchangeFacet is IExchangeEvents {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  // Modifiers.\\n\\n  /// @dev Ensures that a method can only be called by the singleton deployer contract factory.\\n  modifier onlyDeployer() {\\n    require(\\n      msg.sender == LibConstants.DEPLOYER_CONTRACT,\\n      LibConstants.INTERNAL_METHOD\\n    );\\n    _;\\n  }\\n\\n  /** @dev Requires that the message sender is a member of the linked SPC.\\n   */\\n  modifier onlySpcMember() {\\n    require(\\n      IHasMembers(LibExchange.data().spc).isMember(msg.sender),\\n      LibConstants.REQUIRES_SPC_MEMBERSHIP\\n    );\\n    _;\\n  }\\n\\n  /** @dev Requires that the given address is a member of the exchange.\\n   *  @param candidate is the address to be checked.\\n   */\\n  modifier onlyMember(address candidate) {\\n    require(\\n      LibExchangeAccess.data().memberSet.contains(candidate),\\n      LibConstants.REQUIRES_EXCHANGE_MEMBERSHIP\\n    );\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0xd1f058a3dc27f3454dfc87e60402e2f84ef910d7d8a06638005ac20c21c0fbd3\",\"license\":\"MIT\"},\"contracts/exchange/lib/IExchangeEvents.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\ninterface IExchangeEvents {\\n  // IHasMembers.\\n\\n  event MemberAdded(address indexed member);\\n  event MemberRemoved(address indexed member);\\n\\n  // IHasActiveMembers.\\n  event MemberActivated(address indexed member);\\n  event MemberDeactivated(address indexed member);\\n}\\n\",\"keccak256\":\"0x0c17764ae9b192ad9d31fac741fe1239e718f8db0ebd9478b5361a0276dac832\",\"license\":\"MIT\"},\"contracts/exchange/lib/LibExchange.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\n\\nlibrary LibExchange {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Exchange.storage'):\\n  bytes32 internal constant STORAGE_SLOT = 0x58cca9481e011ced58c1d520ef5aad456e5805265d66de8df7c52f680c417394;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev The internal pointer to the SPC contract.\\n    address spc;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0x3a8c32be0f6d238ec402d9afada3bbe00c69875e98fb9968b0f206be0ff23062\",\"license\":\"MIT\"},\"contracts/exchange/lib/LibExchangeAccess.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\n\\nlibrary LibExchangeAccess {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Exchange.storage.Access'):\\n  bytes32 internal constant STORAGE_SLOT = 0x238f5ead2481aef1ec60acdfe5b3de34c076d0a86bb41e30c913f5f3885d7c47;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev This is where we hold our members data.\\n    LibAddressSet.Data memberSet;\\n    /// @dev This is where we keep track of our member FAST memberships.\\n    mapping(address => LibAddressSet.Data) fastMemberships;\\n    /// @dev This is where we keep track of our deactivated memberships.\\n    LibAddressSet.Data deactivatedMemberSet;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0xbfdf94df126ba4a15f865ee9b280c956b36d5c920ba8b8807a5daaf1bf22b82c\",\"license\":\"MIT\"},\"contracts/fast/FastAccessFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../interfaces/IHasMembers.sol';\\nimport '../interfaces/IHasGovernors.sol';\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport '../exchange/ExchangeAccessFacet.sol';\\nimport './FastTokenFacet.sol';\\nimport './lib/AFastFacet.sol';\\nimport './lib/LibFast.sol';\\nimport './lib/LibFastAccess.sol';\\nimport './FastTopFacet.sol';\\nimport './FastFrontendFacet.sol';\\n\\n\\n/**\\n* @dev The FAST Access Smart Contract is the source of truth when it comes to\\n* permissioning and ACLs within a given FAST network.\\n*/\\ncontract FastAccessFacet is AFastFacet, IHasMembers, IHasGovernors {\\n  using LibAddressSet for LibAddressSet.Data;\\n  // Structs.\\n\\n  /**\\n   * @dev This structure isn't used anywhere in storage. Instead, it\\n   * allows various methods of the contract to return all the flags\\n   * associated with a given address in one go.\\n   */\\n  struct Flags {\\n    bool isGovernor;\\n    bool isMember;\\n  }\\n\\n  // Constants.\\n\\n  // This represents how much Eth we provision new governors with.\\n  uint256 constant private GOVERNOR_ETH_PROVISION = 10 ether;\\n  // This represents how much Eth we provision new members with.\\n  uint256 constant private MEMBER_ETH_PROVISION = 1 ether;\\n\\n  // Governorship related stuff.\\n\\n  /**\\n   * @dev Queries whether a given address is a governor or not.\\n   */\\n  function isGovernor(address candidate)\\n      external view override returns(bool) {\\n    return LibFastAccess.data().governorSet.contains(candidate);\\n  }\\n\\n  /**\\n   * @dev Queries the number of governors in the governor list.\\n   */\\n  function governorCount()\\n      external override view returns(uint256) {\\n    return LibFastAccess.data().governorSet.values.length;\\n  }\\n\\n  /**\\n   * @dev Returns a page of governors.\\n   */\\n  function paginateGovernors(uint256 index, uint256 perPage)\\n      external override view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibFastAccess.\\n      data().governorSet.values,\\n      index,\\n      perPage\\n    );\\n  }\\n\\n  /**\\n   * @dev Adds a governor to the governor list.\\n   */\\n  function addGovernor(address payable governor)\\n      external override\\n      onlySpcMember {\\n    // Add governor to list.\\n    LibFastAccess.data().governorSet.add(governor, false);\\n    // If the address is a regular wallet...\\n    if (!LibHelpers.isContract(governor)) {\\n      // Provision the new governor with Eth if possible.\\n      FastTopFacet(payable(address(this))).payUpTo(governor, GOVERNOR_ETH_PROVISION);\\n    }\\n    // Emit!\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n    emit GovernorAdded(governor);\\n  }\\n\\n  /**\\n   * @dev Removes a governor from the governor list.\\n   */\\n  function removeGovernor(address governor)\\n      external override\\n      onlySpcMember {\\n    // Remove governor.\\n    LibFastAccess.data().governorSet.remove(governor, false);\\n    // Emit!\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n    emit GovernorRemoved(governor);\\n  }\\n\\n  /// Membership related stuff.\\n\\n  /**\\n   * @dev Queries whether a given address is a member or not.\\n   */\\n  function isMember(address candidate)\\n      external override view returns(bool) {\\n    return LibFastAccess.data().memberSet.contains(candidate);\\n  }\\n\\n  /**\\n   * @dev Queries the number of members in the membership list.\\n   */\\n  function memberCount()\\n      external override view returns(uint256) {\\n    return LibFastAccess.data().memberSet.values.length;\\n  }\\n\\n  /**\\n   * @dev Returns a page of members.\\n   */\\n  function paginateMembers(uint256 index, uint256 perPage)\\n      external override view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(\\n      LibFastAccess.data().memberSet.values,\\n      index,\\n      perPage\\n    );\\n  }\\n\\n  /**\\n   * @dev Adds a member to the membership list.\\n   */\\n  function addMember(address payable member)\\n      external override \\n      onlyGovernor(msg.sender) onlyExchangeMember(member) {\\n    // Add the member.\\n    LibFastAccess.data().memberSet.add(member, false);\\n    // If the address is a regular wallet...\\n    if (!LibHelpers.isContract(member)) {\\n      // Provision the new member with Eth if possible.\\n      FastTopFacet(payable(address(this))).payUpTo(member, MEMBER_ETH_PROVISION);\\n    }\\n    // Notify exchange that this member was added to this FAST.\\n    ExchangeAccessFacet(LibFast.data().exchange).memberAddedToFast(member);\\n    // Emit!\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n    emit MemberAdded(member);\\n  }\\n\\n  /**\\n   * @dev Removes a member from the membership list.\\n   */\\n  function removeMember(address member)\\n      external override \\n      onlyGovernor(msg.sender) {\\n    // Remove member.\\n    LibFastAccess.data().memberSet.remove(member, false);\\n    // Notify token facet that this member was removed.\\n    FastTokenFacet(address(this)).beforeRemovingMember(member);\\n    // Notify exchange that this member was removed from this FAST.\\n    ExchangeAccessFacet(LibFast.data().exchange).memberRemovedFromFast(member);\\n    // Emit!\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n    emit MemberRemoved(member);\\n  }\\n\\n  /// Flags.\\n\\n  /**\\n   * @dev Retrieves flags for a given address.\\n   */\\n  function flags(address a)\\n      external view returns(Flags memory) {\\n    LibFastAccess.Data storage s = LibFastAccess.data();\\n    return\\n      Flags({\\n        isGovernor: s.governorSet.contains(a),\\n        isMember: s.memberSet.contains(a)\\n      });\\n  }\\n}\\n\",\"keccak256\":\"0x115709811cfb5b1f2395b350f70968629d69acd320ec58afa99329fc3a7b6a1d\",\"license\":\"MIT\"},\"contracts/fast/FastFrontendFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport './lib/AFastFacet.sol';\\nimport './lib/LibFastAccess.sol';\\nimport './lib/LibFastToken.sol';\\n\\n\\ncontract FastFrontendFacet is AFastFacet {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  // Data structures.\\n\\n  struct Details {\\n    address addr;\\n    string name;\\n    string symbol;\\n    uint256 decimals;\\n    uint256 totalSupply;\\n    uint256 transferCredits;\\n    bool isSemiPublic;\\n    bool hasFixedSupply;\\n    uint256 reserveBalance;\\n    uint256 ethBalance;\\n    uint256 memberCount;\\n    uint256 governorCount;\\n  }\\n\\n  struct MemberDetails {\\n    address addr;\\n    uint256 balance;\\n    uint256 ethBalance;\\n    bool isGovernor;\\n  }\\n\\n  // Emitters.\\n\\n  function emitDetailsChanged()\\n      external onlyDiamondFacet {\\n    LibFastAccess.Data storage accessData = LibFastAccess.data();\\n    LibFastToken.Data storage tokenData = LibFastToken.data();\\n    emit DetailsChanged({\\n      memberCount: accessData.memberSet.values.length,\\n      governorCount: accessData.governorSet.values.length,\\n      totalSupply: tokenData.totalSupply,\\n      transferCredits: tokenData.transferCredits,\\n      reserveBalance: tokenData.balances[LibConstants.ZERO_ADDRESS],\\n      ethBalance: payable(address(this)).balance\\n    });\\n  }\\n\\n  // Public functions.\\n\\n  function details()\\n      public view returns(Details memory) {\\n    LibFast.Data storage topStorage = LibFast.data();\\n    LibFastAccess.Data storage accessStorage = LibFastAccess.data();\\n    LibFastToken.Data storage tokenStorage = LibFastToken.data();\\n    return Details({\\n      addr: address(this),\\n      name: tokenStorage.name,\\n      symbol: tokenStorage.symbol,\\n      decimals: tokenStorage.decimals,\\n      totalSupply: tokenStorage.totalSupply,\\n      transferCredits: tokenStorage.transferCredits,\\n      isSemiPublic: topStorage.isSemiPublic,\\n      hasFixedSupply: topStorage.hasFixedSupply,\\n      reserveBalance: tokenStorage.balances[LibConstants.ZERO_ADDRESS],\\n      ethBalance: payable(address(this)).balance,\\n      memberCount: accessStorage.memberSet.values.length,\\n      governorCount: accessStorage.governorSet.values.length\\n    });\\n  }\\n\\n  function detailedMember(address member)\\n      public view returns(MemberDetails memory) {\\n    LibFastToken.Data storage tokenStorage = LibFastToken.data();\\n    LibFastAccess.Data storage accessStorage = LibFastAccess.data();\\n    return MemberDetails({\\n      addr: member,\\n      balance: tokenStorage.balances[member],\\n      ethBalance: member.balance,\\n      isGovernor: accessStorage.governorSet.contains(member)\\n    });\\n  }\\n\\n  function paginateDetailedMembers(uint256 index, uint256 perPage)\\n      external view returns(MemberDetails[] memory, uint256) {\\n    LibFastAccess.Data storage accessStorage = LibFastAccess.data();\\n    (address[] memory members, uint256 nextCursor) =\\n      LibPaginate.addresses(accessStorage.memberSet.values, index, perPage);\\n    MemberDetails[] memory values = new MemberDetails[](members.length);\\n    for (uint256 i = 0; i < members.length; ++i) {\\n      values[i] = detailedMember(members[i]);\\n    }\\n    return (values, nextCursor);\\n  }\\n}\\n\",\"keccak256\":\"0xc1227904923f6b4630faac8f765e3123882154f9631f6a886a17ceac37d7b11f\",\"license\":\"MIT\"},\"contracts/fast/FastHistoryFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibPaginate.sol';\\nimport './lib/AFastFacet.sol';\\nimport './lib/LibFastHistory.sol';\\n\\n\\ncontract FastHistoryFacet is AFastFacet {\\n  /// Minting history-keeping methods.\\n\\n  function minted(uint256 amount, string calldata ref)\\n      external onlyDiamondFacet() {\\n    // Keep track of the mint.\\n    LibFastHistory.data().supplyProofs.push(\\n      LibFastHistory.SupplyProof({\\n        op: LibFastHistory.SupplyOp.Mint,\\n        amount: amount,\\n        blockNumber: block.number,\\n        ref: ref\\n      })\\n    );\\n  }\\n\\n  function burnt(uint256 amount, string calldata ref)\\n      external onlyDiamondFacet() {\\n    // Keep track of the unmint.\\n    LibFastHistory.data().supplyProofs.push(\\n      LibFastHistory.SupplyProof({\\n        op: LibFastHistory.SupplyOp.Burn,\\n        amount: amount,\\n        blockNumber: block.number,\\n        ref: ref\\n      })\\n    );\\n  }\\n\\n  function supplyProofCount()\\n      external view returns(uint256) {\\n    return LibFastHistory.data().supplyProofs.length;\\n  }\\n\\n  function paginateSupplyProofs(uint256 cursor, uint256 perPage)\\n      external view returns(LibFastHistory.SupplyProof[] memory, uint256) {\\n    return LibPaginate.supplyProofs(LibFastHistory.data().supplyProofs, cursor, perPage);\\n  }\\n\\n  /// Transfer history-keeping methods.\\n\\n  function transfered(address spender, address from, address to, uint256 amount, string calldata ref)\\n      external onlyDiamondFacet() {\\n    LibFastHistory.Data storage s = LibFastHistory.data();\\n    // Keep track of the transfer proof ID for the sender and for the recipient.\\n    s.transferProofInvolvements[from].push(s.transferProofs.length);\\n    s.transferProofInvolvements[to].push(s.transferProofs.length);\\n    // Keep track of the transfer proof globally.\\n    s.transferProofs.push(\\n      LibFastHistory.TransferProof({\\n        spender: spender,\\n        from: from,\\n        to: to,\\n        amount: amount,\\n        blockNumber: block.number,\\n        ref: ref\\n      })\\n    );\\n  }\\n\\n  function transferProofCount()\\n      external view returns(uint256) {\\n    return LibFastHistory.data().transferProofs.length;\\n  }\\n\\n  function paginateTransferProofs(uint256 cursor, uint256 perPage)\\n      external view returns(LibFastHistory.TransferProof[] memory, uint256) {\\n    return LibPaginate.transferProofs(LibFastHistory.data().transferProofs, cursor, perPage);\\n  }\\n\\n  function transferProofByInvolveeCount(address involvee)\\n      external view returns(uint256) {\\n    return LibFastHistory.data().transferProofInvolvements[involvee].length;\\n  }\\n\\n  function paginateTransferProofIndicesByInvolvee(address involvee, uint256 cursor, uint256 perPage)\\n      external view returns(uint256[] memory, uint256) {\\n    return LibPaginate.uint256s(LibFastHistory.data().transferProofInvolvements[involvee], cursor, perPage);\\n  }\\n\\n  function paginateTransferProofsByInvolvee(address involvee, uint256 cursor, uint256 perPage)\\n      external view returns(LibFastHistory.TransferProof[] memory, uint256) {\\n    LibFastHistory.Data storage s = LibFastHistory.data();\\n    uint256[] storage collection  = s.transferProofInvolvements[involvee];\\n    uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n    LibFastHistory.TransferProof[] memory values = new LibFastHistory.TransferProof[](length);\\n    for (uint256 i = 0; i < length; i++) {\\n      values[i] = s.transferProofs[collection[cursor + i]];\\n    }\\n    return (values, cursor + length);\\n  }\\n}\\n\",\"keccak256\":\"0xaafd047e60319fd6ac2f61d133b97e61ae656237d858d95d6fc680c3114e9ab5\",\"license\":\"MIT\"},\"contracts/fast/FastTokenFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../interfaces/IERC20.sol';\\nimport '../interfaces/IERC1404.sol';\\nimport '../interfaces/IHasMembers.sol';\\nimport '../interfaces/IHasGovernors.sol';\\nimport '../lib/LibDiamond.sol';\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport './lib/AFastFacet.sol';\\nimport './lib/LibFastToken.sol';\\nimport './lib/IFast.sol';\\nimport './FastTopFacet.sol';\\nimport './FastAccessFacet.sol';\\nimport './FastHistoryFacet.sol';\\nimport './FastFrontendFacet.sol';\\n\\n\\ncontract FastTokenFacet is AFastFacet, IERC20, IERC1404 {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  // Minting methods.\\n\\n  function mint(uint256 amount, string calldata ref)\\n      external\\n      onlySpcMember {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    // We want to make sure that either of these two is true:\\n    // - The token doesn't have fixed supply.\\n    // - The token has fixed supply but has no tokens yet (First and only mint).\\n    require(\\n      !FastTopFacet(address(this)).hasFixedSupply() || (s.totalSupply == 0 && this.balanceOf(address(0)) == 0),\\n      LibConstants.REQUIRES_CONTINUOUS_SUPPLY\\n    );\\n\\n    // Prepare the minted amount on the zero address.\\n    s.balances[address(0)] += amount;\\n\\n    // Keep track of the minting operation.\\n    FastHistoryFacet(address(this)).minted(amount, ref);\\n\\n    // Emit!\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n    emit Minted(amount, ref);\\n  }\\n\\n  function burn(uint256 amount, string calldata ref)\\n      external\\n      onlySpcMember {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    require(!FastTopFacet(address(this)).hasFixedSupply(), LibConstants.REQUIRES_CONTINUOUS_SUPPLY);\\n    require(balanceOf(address(0)) >= amount, LibConstants.INSUFFICIENT_FUNDS);\\n\\n    // Remove the minted amount from the zero address.\\n    s.balances[address(0)] -= amount;\\n\\n    // Keep track of the minting operation.\\n    FastHistoryFacet(address(this)).burnt(amount, ref);\\n\\n    // Emit!\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n    emit Burnt(amount, ref);\\n  }\\n\\n  // Tranfer Credit management.\\n\\n  function transferCredits()\\n      external view returns(uint256) {\\n    return LibFastToken.data().transferCredits;\\n  }\\n\\n  function addTransferCredits(uint256 amount)\\n      external\\n      onlySpcMember {\\n    LibFastToken.data().transferCredits += amount;\\n    // Emit!\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n    emit TransferCreditsAdded(msg.sender, amount);\\n  }\\n\\n  function drainTransferCredits()\\n      external\\n      onlySpcMember {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    // Emit!\\n    emit TransferCreditsDrained(msg.sender, s.transferCredits);\\n    // Drain credits.\\n    s.transferCredits = 0;\\n    // Emit!\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n  }\\n\\n  // ERC20 implementation and transfer related methods.\\n\\n  function name()\\n      external view returns(string memory) {\\n    return LibFastToken.data().name;\\n  }\\n\\n  function symbol()\\n      external view returns(string memory) {\\n    return LibFastToken.data().symbol;\\n  }\\n\\n  function decimals()\\n      external view returns(uint256) {\\n    return LibFastToken.data().decimals;\\n  }\\n\\n  function totalSupply()\\n      external override view returns(uint256) {\\n    return LibFastToken.data().totalSupply;\\n  }\\n\\n  function balanceOf(address owner)\\n      public view override returns(uint256) {\\n    return LibFastToken.data().balances[owner];\\n  }\\n\\n  function transfer(address to, uint256 amount)\\n      external override returns(bool) {\\n    // Make sure the call is performed externally so that we can mock.\\n    this.performTransfer(\\n      TransferArgs({\\n        spender: msg.sender,\\n        from: msg.sender,\\n        to: to,\\n        amount: amount,\\n        ref: LibFastToken.DEFAULT_TRANSFER_REFERENCE\\n      })\\n    );\\n    return true;\\n  }\\n\\n  function transferWithRef(address to, uint256 amount, string calldata ref)\\n      external {\\n    // Make sure the call is performed externally so that we can mock.\\n    this.performTransfer(\\n      TransferArgs({\\n        spender: msg.sender,\\n        from: msg.sender,\\n        to: to,\\n        amount: amount,\\n        ref: ref\\n      })\\n    );\\n  }\\n\\n  function allowance(address owner, address spender)\\n      public view override returns(uint256) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    // If the allowance being queried is from the zero address and the spender\\n    // is a governor, we want to make sure that the spender has full rights over it.\\n    if (owner == address(0)) {\\n      require(FastAccessFacet(address(this)).isGovernor(spender), LibConstants.REQUIRES_FAST_GOVERNORSHIP);\\n      return s.balances[owner];\\n    }\\n    return s.allowances[owner][spender];\\n  }\\n\\n  function approve(address spender, uint256 amount)\\n      external override returns(bool) {\\n    // Make sure the call is performed externally so that we can mock.\\n    this.performApproval(msg.sender, spender, amount);\\n    return true;\\n  }\\n\\n  function disapprove(address spender)\\n      external\\n      onlyMember(msg.sender) {\\n    // Make sure the call is performed externally so that we can mock.\\n    this.performDisapproval(msg.sender, spender);\\n  }\\n\\n  function transferFrom(address from, address to, uint256 amount)\\n      external override returns(bool) {\\n    transferFromWithRef(from, to, amount, LibFastToken.DEFAULT_TRANSFER_REFERENCE);\\n    return true;\\n  }\\n\\n  function transferFromWithRef(address from, address to, uint256 amount, string memory ref)\\n      public {\\n    // Make sure the call is performed externally so that we can mock.\\n    this.performTransfer(\\n      TransferArgs({\\n        spender: msg.sender,\\n        from: from,\\n        to: to,\\n        amount: amount,\\n        ref: ref\\n      })\\n    );\\n  }\\n\\n  // Allowances query operations.\\n\\n  function givenAllowanceCount(address owner)\\n      external view returns(uint256) {\\n    return LibFastToken.data().allowancesByOwner[owner].values.length;\\n  }\\n\\n  function paginateAllowancesByOwner(address owner, uint256 index, uint256 perPage)\\n      external view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(\\n      LibFastToken.data().allowancesByOwner[owner].values,\\n      index,\\n      perPage\\n    );\\n  }\\n\\n  function receivedAllowanceCount(address spender)\\n      external view returns(uint256) {\\n    return LibFastToken.data().allowancesBySpender[spender].values.length;\\n  }\\n\\n  function paginateAllowancesBySpender(address spender, uint256 index, uint256 perPage)\\n      external view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(\\n      LibFastToken.data().allowancesBySpender[spender].values,\\n      index,\\n      perPage\\n    );\\n  }\\n\\n  // ERC1404 implementation.\\n\\n  function detectTransferRestriction(address from, address to, uint256 amount)\\n      external view override returns(uint8) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    if (s.transferCredits < amount) {\\n      return LibFastToken.INSUFFICIENT_TRANSFER_CREDITS_CODE;\\n    } else if (!FastAccessFacet(address(this)).isMember(from) ||\\n               !FastAccessFacet(address(this)).isMember(to)) {\\n      return FastTopFacet(address(this)).isSemiPublic()\\n        ? LibFastToken.REQUIRES_EXCHANGE_MEMBERSHIP_CODE\\n        : LibFastToken.REQUIRES_FAST_MEMBERSHIP_CODE;\\n    } else if (from == to) {\\n      return LibFastToken.REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT_CODE;\\n    }\\n    return 0;\\n  }\\n\\n  function messageForTransferRestriction(uint8 restrictionCode)\\n      external override pure returns(string memory) {\\n    if (restrictionCode == LibFastToken.INSUFFICIENT_TRANSFER_CREDITS_CODE) {\\n      return LibConstants.INSUFFICIENT_TRANSFER_CREDITS;\\n    } else if (restrictionCode == LibFastToken.REQUIRES_EXCHANGE_MEMBERSHIP_CODE) {\\n      return LibConstants.REQUIRES_EXCHANGE_MEMBERSHIP;\\n    } else if (restrictionCode == LibFastToken.REQUIRES_FAST_MEMBERSHIP_CODE) {\\n      return LibConstants.REQUIRES_FAST_MEMBERSHIP;\\n    } else if (restrictionCode == LibFastToken.REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT_CODE) {\\n      return LibConstants.REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT;\\n    }\\n    revert(LibConstants.UNKNOWN_RESTRICTION_CODE);\\n  }\\n\\n  // These functions would be internal / private if we weren't using the diamond pattern.\\n  // Instead, they're `onlyDiamondFacet` - eg can only be called by facets of the current\\n  // FAST.\\n\\n  struct TransferArgs {\\n    address spender;\\n    address from;\\n    address to;\\n    uint256 amount;\\n    string ref;\\n  }\\n\\n  function performTransfer(TransferArgs calldata p)\\n      external onlyDiamondFacet\\n      differentAddresses(p.from, p.to)\\n      onlyTokenHolder(p.from)\\n      onlyExchangeActiveMember(p.from)\\n      onlyTokenHolder(p.to) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    // Make sure that there's enough funds.\\n    require(\\n      s.balances[p.from] >= p.amount,\\n      LibConstants.INSUFFICIENT_FUNDS\\n    );\\n    require(\\n      p.amount > 0,\\n      LibConstants.UNSUPPORTED_OPERATION\\n    );\\n\\n    // If this is an allowance transfer...\\n    if (p.spender != p.from) {\\n      // Make sure that the spender has enough allowance.\\n      require(\\n        FastTokenFacet(address(this)).allowance(p.from, p.spender) >= p.amount,\\n        LibConstants.INSUFFICIENT_ALLOWANCE\\n      );\\n\\n      // If the from account isn't the zero address...\\n      if (p.from != address(0)) {\\n        // Decrease allowance.\\n        uint256 newAllowance = s.allowances[p.from][p.spender] -= p.amount;\\n        // If the allowance reached zero, we want to remove that allowance from\\n        // the various other places where we keep track of it.\\n        if (newAllowance == 0) {\\n          s.allowancesByOwner[p.from].remove(p.spender, true);\\n          s.allowancesBySpender[p.spender].remove(p.from, true);\\n        }\\n      }\\n    }\\n\\n    // Keep track of the balances - `from` spends, `to` receives.\\n    s.balances[p.from] -= p.amount;\\n    s.balances[p.to] += p.amount;\\n\\n    // If the funds are not moving from the zero address, decrease transfer credits.\\n    if (p.from != address(0)) {\\n      // Make sure enough credits exist.\\n      require(\\n        s.transferCredits >= p.amount,\\n        LibConstants.INSUFFICIENT_TRANSFER_CREDITS\\n      );\\n      s.transferCredits -= p.amount;\\n    }\\n\\n    // If the funds are going to the ZERO address, decrease total supply.\\n    if (p.to == address(0)) {\\n      s.totalSupply -= p.amount;\\n      // If funds at address zero changed, we can emit a top-level details change event.\\n      FastFrontendFacet(address(this)).emitDetailsChanged();\\n    }\\n    // If the funds are moving from the zero address, increase total supply.\\n    else if (p.from == address(0)) {\\n      s.totalSupply += p.amount;\\n      // If funds at address zero changed, we can emit a top-level details change event.\\n      FastFrontendFacet(address(this)).emitDetailsChanged();\\n    }\\n\\n    // Keep track of the transfer in the history facet.\\n    FastHistoryFacet(address(this)).transfered(p.spender, p.from, p.to, p.amount, p.ref);\\n\\n    // Emit!\\n    emit Transfer(p.from, p.to, p.amount);\\n  }\\n\\n  function performApproval(address from, address spender, uint256 amount)\\n      external\\n      onlyDiamondFacet\\n      onlyTokenHolder(from) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    // Store allowance...\\n    s.allowances[from][spender] += amount;\\n    // Keep track of given and received allowances.\\n    s.allowancesByOwner[from].add(spender, true);\\n    s.allowancesBySpender[spender].add(from, true);\\n\\n    // Emit!\\n    emit Approval(from, spender, amount);\\n  }\\n\\n  function performDisapproval(address from, address spender)\\n      external\\n      onlyDiamondFacet {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    // Remove allowance.\\n    s.allowances[from][spender] = 0;\\n    s.allowancesByOwner[from].remove(spender, false);\\n    s.allowancesBySpender[spender].remove(from, false);\\n\\n    // Emit!\\n    emit Disapproval(from, spender);\\n  }\\n\\n  // WARNING: This function contains two loops. We know that this should never\\n  // happen in solidity. However:\\n  // - In the context of our private chain, gas is cheap.\\n  // - It can only be called by a governor.\\n  function beforeRemovingMember(address member)\\n      external onlyDiamondFacet() {\\n    require(balanceOf(member) == 0, 'Balance is positive');\\n\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    // Remove all given allowances.\\n    address[] storage gaData = s.allowancesByOwner[member].values;\\n    while (gaData.length > 0) {\\n      // Make sure the call is performed externally so that we can mock.\\n      this.performDisapproval(member, gaData[0]);\\n    }\\n\\n    // Remove all received allowances.\\n    address[] storage raData = s.allowancesBySpender[member].values;\\n    while (raData.length > 0) {\\n      // Make sure the call is performed externally so that we can mock.\\n      this.performDisapproval(raData[0], member);\\n    }\\n  }\\n\\n  // Modifiers.\\n\\n  /** @dev Ensures that the given address is a member of the current FAST or the Zero Address.\\n   *  @param candidate The address to check.\\n   */\\n  modifier onlyTokenHolder(address candidate) {\\n    // Only perform checks if the address is non-zero.\\n    if (candidate != address(0)) {\\n    // FAST is semi-public - the only requirement to hold tokens is to be an exchange member.\\n      if (IFast(address(this)).isSemiPublic()) {\\n        require(\\n          IHasMembers(LibFast.data().exchange).isMember(candidate),\\n          LibConstants.REQUIRES_EXCHANGE_MEMBERSHIP\\n        );\\n      }\\n      // FAST is private, the requirement to hold tokens is to be a member of that FAST.\\n      else {\\n        require(\\n          IHasMembers(address(this)).isMember(candidate),\\n          LibConstants.REQUIRES_FAST_MEMBERSHIP\\n        );\\n      }\\n    }\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x135502ebffda0d70b80c113ea020edd542dadfc7e890d5b292dc91499a5be2e9\",\"license\":\"MIT\"},\"contracts/fast/FastTopFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibConstants.sol';\\nimport '../lib/LibHelpers.sol';\\nimport './lib/AFastFacet.sol';\\nimport './lib/LibFast.sol';\\nimport './lib/IFastEvents.sol';\\nimport './FastFrontendFacet.sol';\\n\\ncontract FastTopFacet is AFastFacet {\\n  // Getters and setters for global flags.\\n\\n  function spcAddress()\\n      external view returns(address) {\\n    return LibFast.data().spc;\\n  }\\n\\n  function exchangeAddress()\\n      external view returns(address) {\\n    return LibFast.data().exchange;\\n  }\\n\\n  function isSemiPublic()\\n      external view returns(bool) {\\n    return LibFast.data().isSemiPublic;\\n  }\\n\\n  function hasFixedSupply()\\n      external view returns(bool) {\\n    return LibFast.data().hasFixedSupply;\\n  }\\n\\n  // Setters for global flags.\\n\\n  /// @dev Allows to switch from a private scheme to a semi-public scheme, but not the other way around.\\n  function setIsSemiPublic(bool flag)\\n      external\\n      onlySpcMember {\\n    LibFast.Data storage s = LibFast.data();\\n    // Someone is trying to toggle back to private?... No can do!isSemiPublic\\n    require(!this.isSemiPublic() || this.isSemiPublic() == flag, LibConstants.UNSUPPORTED_OPERATION);\\n    s.isSemiPublic = flag;\\n    // Emit!\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n  }\\n\\n  // Provisioning functions.\\n\\n  function provisionWithEth()\\n      external payable {\\n    require(msg.value > 0, LibConstants.MISSING_ATTACHED_ETH);\\n    emit EthReceived(msg.sender, msg.value);\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n  }\\n\\n  function drainEth()\\n      onlySpcMember nonContract(msg.sender)\\n      external {\\n    uint256 amount = payable(address(this)).balance;\\n    payable(msg.sender).transfer(amount);\\n    emit EthDrained(msg.sender, amount);\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n  }\\n\\n  /**\\n  * @dev This function allows contracts of the FAST network to request ETH\\n  * provisioning to arbitrary addresses.\\n  */\\n  function payUpTo(address payable recipient, uint256 amount)\\n      nonContract(recipient)\\n      external onlyDiamondFacet {\\n    require(\\n      recipient != address(0),\\n      LibConstants.REQUIRES_NON_ZERO_ADDRESS\\n    );\\n    amount = LibHelpers.upTo(recipient, amount);\\n    // Transfer some eth!\\n    if (amount != 0) { recipient.transfer(amount); }\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n  }\\n}\\n\",\"keccak256\":\"0x88af3c18a8c24a15a197f5f08014ba59bb931f410847358beb8ce8ff1baf2085\",\"license\":\"MIT\"},\"contracts/fast/lib/AFastFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibConstants.sol';\\nimport '../../lib/LibHelpers.sol';\\nimport '../../lib/LibAddressSet.sol';\\nimport '../../interfaces/IHasMembers.sol';\\nimport '../../interfaces/IHasGovernors.sol';\\nimport '../../interfaces/IHasActiveMembers.sol';\\nimport '../../interfaces/IERC173.sol';\\nimport '../lib/LibFast.sol';\\nimport './IFastEvents.sol';\\n\\n\\n/**\\n* @dev This contract is a group of modifiers that can be used by any facets to guard against\\n*       certain permissions.\\n*/\\nabstract contract AFastFacet is IFastEvents {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  /// Modifiers.\\n\\n  /// @dev Ensures that a method can only be called by another facet of the same diamond.\\n  modifier onlyDiamondFacet() {\\n    require(\\n      msg.sender == address(this),\\n      LibConstants.INTERNAL_METHOD\\n    );\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the owner of this diamond.\\n  modifier onlyDiamondOwner() {\\n    require(\\n      msg.sender == IERC173(address(this)).owner(),\\n      LibConstants.REQUIRES_DIAMOND_OWNERSHIP\\n    );\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the singleton deployer contract factory.\\n  modifier onlyDeployer() {\\n    require(\\n      msg.sender == LibConstants.DEPLOYER_CONTRACT,\\n      LibConstants.INTERNAL_METHOD\\n    );\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is **not** a contract.\\n   *  @param candidate The address to check.\\n   */\\n  modifier nonContract(address candidate) {\\n    require(\\n      !LibHelpers.isContract(candidate),\\n      LibConstants.REQUIRES_NON_CONTRACT_ADDR\\n    );\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is a member of the Exchange.\\n   *  @param candidate The address to check.\\n   */\\n  modifier onlyExchangeMember(address candidate) {\\n    require(\\n      IHasMembers(LibFast.data().exchange).isMember(candidate),\\n      LibConstants.REQUIRES_EXCHANGE_MEMBERSHIP\\n    );\\n    _;\\n  }\\n\\n  /** @dev Ensures a candidate is active.\\n   *  @param candidate The address to check activation status on.\\n   */\\n  modifier onlyExchangeActiveMember(address candidate) {\\n    require(\\n      IHasActiveMembers(LibFast.data().exchange).isMemberActive(candidate),\\n      LibConstants.REQUIRES_EXCHANGE_ACTIVE_MEMBER\\n    );\\n    _;\\n  }\\n\\n  /** @dev Ensures that the message sender is a member of the SPC.\\n   */\\n  modifier onlySpcMember() {\\n    require(\\n      IHasMembers(LibFast.data().spc).isMember(msg.sender),\\n      LibConstants.REQUIRES_SPC_MEMBERSHIP\\n    );\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is a governor of the FAST.\\n   *  @param candidate The address to check.\\n   */\\n  modifier onlyGovernor(address candidate) {\\n    require(\\n      IHasGovernors(address(this)).isGovernor(candidate),\\n      LibConstants.REQUIRES_FAST_GOVERNORSHIP\\n    );\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is a member of the FAST.\\n   *  @param candidate The address to check.\\n   */\\n  modifier onlyMember(address candidate) {\\n    require(\\n      IHasMembers(address(this)).isMember(candidate),\\n      LibConstants.REQUIRES_FAST_MEMBERSHIP\\n    );\\n    _;\\n  }\\n\\n  /** @dev Ensures address a is different from address b.\\n   *  @param a Address a\\n   *  @param b Address b\\n   */\\n  modifier differentAddresses(address a, address b) {\\n    require(a != b, LibConstants.REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT);\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x4c2776adecc2aea74aec923b1e416820e9e224f91f378b6bde4f95a914d531b2\",\"license\":\"MIT\"},\"contracts/fast/lib/IFast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\ninterface IFast {\\n  function isSemiPublic() external view returns(bool);\\n  function hasFixedSupply() external view returns(bool);\\n}\\n\",\"keccak256\":\"0xea7b5645ce61b4f3c399bb1696603c57833e1f0b2fcce935f6420f55d602ba64\",\"license\":\"MIT\"},\"contracts/fast/lib/IFastEvents.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\ninterface IFastEvents {\\n  // ETH provisioning events.\\n\\n  /** @dev Emited when someone provisions this SPC with Eth.\\n   *  @param from The sender of the Eth.\\n   *  @param amount The quantity of Eth, expressed in Wei.\\n   */\\n  event EthReceived(address indexed from, uint256 amount);\\n  /** @dev Emited when Eth is drained from this SPC.\\n   *  @param to The caller and recipient of the drained Eth.\\n   *  @param amount The quantity of Eth that was drained, expressed in Wei.\\n   */\\n  event EthDrained(address indexed to, uint256 amount);\\n\\n  // IHasMembers.\\n\\n  event MemberAdded(address indexed member);\\n  event MemberRemoved(address indexed member);\\n\\n  // IHasGovernors.\\n\\n  event GovernorAdded(address indexed governor);\\n  event GovernorRemoved(address indexed governor);\\n\\n  // Token related events.\\n\\n  // Issuance related events.\\n  event Minted(uint256 indexed amount, string indexed ref);\\n  event Burnt(uint256 indexed amount, string indexed ref);\\n\\n  // Transfer credits related events.\\n  event TransferCreditsAdded(address indexed spcMember, uint256 amount);\\n  event TransferCreditsDrained(address indexed spcMember, uint256 amount);\\n\\n  // ERC20 stuff.\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n  event Disapproval(address indexed owner, address indexed spender);\\n\\n  // General events.\\n\\n  // This is an event that is fired whenever any of some of the FAST parameters\\n  // change, so that the frontend can react to it and refresh the general header\\n  // for that fast as well as the baseball cards in the FASTs list.\\n  event DetailsChanged(\\n    uint256 memberCount,\\n    uint256 governorCount,\\n    uint256 totalSupply,\\n    uint256 transferCredits,\\n    uint256 reserveBalance,\\n    uint256 ethBalance\\n  );\\n}\\n\",\"keccak256\":\"0xee03f5d995981475006529690d658b6e74d1eb154071080568000d3ac746f26b\",\"license\":\"MIT\"},\"contracts/fast/lib/LibFast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\nlibrary LibFast {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Fast.storage'):\\n  bytes32 internal constant STORAGE_SLOT = 0x80c187ea6f955fd624c41fb7a18011cc87d98c6f4c06d897b59142f65707e705;\\n\\n  // Data structures.\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev The internal pointer to the SPC contract.\\n    address spc;\\n    /// @dev The internal pointer to the Exchange contract.\\n    address exchange;\\n    /// @dev We have to track whether the token facet provides continuous minting or fixed supply.\\n    bool hasFixedSupply;\\n    /// @dev Whether or not this FAST requires to be a member to hold tokens.\\n    bool isSemiPublic;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0xc32df23d24f8ec8c918f1caeb8ca984bfe2ac1b7c370f24ad2a70a52e9d4e999\",\"license\":\"MIT\"},\"contracts/fast/lib/LibFastAccess.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\nlibrary LibFastAccess {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Fast.storage.Access'):\\n  bytes32 internal constant STORAGE_SLOT = 0x87ed8063ac9ead3b2eb7551ed3d89b29fcbf44d6733084b5c82e95d5120ece9a;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev We hold the list of the FAST governors in there.\\n    LibAddressSet.Data governorSet;\\n    // @dev The FAST members are held in there.\\n    LibAddressSet.Data memberSet;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0x9744c77467b854899d5b5f9beaf4665f461adc8110432d174601a97f00e594ad\",\"license\":\"MIT\"},\"contracts/fast/lib/LibFastHistory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\nlibrary LibFastHistory {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Fast.storage.History'):\\n  bytes32 internal constant STORAGE_SLOT = 0x6bc8b61a9dd5fc049ea98027492a801d74e35fdf4d80d7fecd551a16e88fdbb4;\\n\\n  // Storage structures.\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev All minting proofs are kept here.\\n    SupplyProof[] supplyProofs;\\n    /// @dev All transfer proofs are kept here.\\n    TransferProof[] transferProofs;\\n    /// @dev All transfers indices involving a given address are kept here.\\n    mapping(address => uint256[]) transferProofInvolvements;\\n  }\\n\\n  // Other structures.\\n\\n  /// @dev A minting operation could either be to mint or unmint tokens.\\n  enum SupplyOp { Mint, Burn }\\n\\n  /// @dev Minting operations are recorded for papertrail. This is the structure that keeps track of them.\\n  struct SupplyProof {\\n    SupplyOp op;\\n    uint256 amount;\\n    uint256 blockNumber;\\n    string ref;\\n  }\\n\\n  /// @dev Every transfer in is recorded. This is the structure that keeps track of them.\\n  struct TransferProof {\\n    address spender;\\n    address from;\\n    address to;\\n    uint256 amount;\\n    uint256 blockNumber;\\n    string ref;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0xd6af0fc0867dd0259fa6e0797f2b46cffac8a36f0380bf266e3ccf778aeb724c\",\"license\":\"MIT\"},\"contracts/fast/lib/LibFastToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\n\\nlibrary LibFastToken {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Fast.storage.Token'):\\n  bytes32 internal constant STORAGE_SLOT = 0xb098747b87c5c0e2a32eb9b06725e9bad4263809bcda628ceadc1a686bcb8261;\\n\\n  // Constants.\\n\\n  // ERC1404 Restriction codes.\\n  uint8 internal constant INSUFFICIENT_TRANSFER_CREDITS_CODE = 1;\\n  uint8 internal constant REQUIRES_FAST_MEMBERSHIP_CODE = 2;\\n  uint8 internal constant REQUIRES_EXCHANGE_MEMBERSHIP_CODE = 3;\\n  uint8 internal constant REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT_CODE = 4;\\n\\n  string internal constant DEFAULT_TRANSFER_REFERENCE = 'Unspecified - via ERC20';\\n\\n  // Data structures.\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    // ERC20 related properties for this FAST Token.\\n    string name;\\n    string symbol;\\n    uint256 decimals;\\n    uint256 totalSupply;\\n    // Every time a transfer is executed, the credit decreases by the amount\\n    // of said transfer.\\n    // It becomes impossible to transact once it reaches zero, and must\\n    // be provisioned by an SPC governor.\\n    uint256 transferCredits;\\n    // Our members balances are held here.\\n    mapping(address => uint256) balances;\\n    // Allowances are stored here.\\n    mapping(address => mapping(address => uint256)) allowances;\\n    mapping(address => LibAddressSet.Data) allowancesByOwner;\\n    mapping(address => LibAddressSet.Data) allowancesBySpender;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0x7255ca8c82f392258f4178b5c80b66c83796e9f25460f9ca690f5c5e250e03db\",\"license\":\"MIT\"},\"contracts/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0x7aca95eacea757ff86be09ed6f309fde42e402530ac7beae002e3c2586439a01\",\"license\":\"MIT\"},\"contracts/interfaces/IERC1404.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\n/**\\n * @dev Interface of the ERC1404 standard as defined in the EIP.\\n */\\ninterface IERC1404 {\\n  /**\\n   * @dev Returns a transfer restriction error code if the transfer shoudln't be permitted,\\n   *      or otherwise returns zero if everything looks fine.\\n   * @param owner is the account from which the tokens should be transfered.\\n   * @param recipient is the target of the transfer.\\n   * @param amount is the amount to be transfered.\\n   * @return a uint8 error code if a problem was detected, otherwise zero.\\n   */\\n  function detectTransferRestriction(address owner, address recipient, uint256 amount)\\n    external\\n    view\\n    returns (uint8);\\n\\n  /**\\n   * @dev Maps a transfer restriction error code into a human-readable string.\\n   * @param code is the code that should be transformed into a string.\\n   * @return A string that describes the given error code.\\n   */\\n  function messageForTransferRestriction(uint8 code) external pure returns (string memory);\\n}\\n\",\"keccak256\":\"0x9ecaada095d66283dda203f77cdd17d18f82bdf58d6fbe7830fc87aed2a80c38\",\"license\":\"MIT\"},\"contracts/interfaces/IERC173.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @title ERC-173 Contract Ownership Standard\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\n/* is ERC165 */\\ninterface IERC173 {\\n    /// @dev This emits when ownership of a contract changes.\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Get the address of the owner\\n    /// @return owner_ The address of the owner.\\n    function owner() external view returns (address owner_);\\n\\n    /// @notice Set the address of the new owner of the contract\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\n    /// @param _newOwner The address of the new owner of the contract\\n    function transferOwnership(address _newOwner) external;\\n}\\n\",\"keccak256\":\"0x6ab22e74708905d9c31867461fffbd2e24bc6ad094aa1aab39211d99e296ab32\",\"license\":\"MIT\"},\"contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x207580afc51139c2cac95644bf77d5fbb152b7abb03397e8d3c7992d0e8ad883\",\"license\":\"MIT\"},\"contracts/interfaces/IHasActiveMembers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\ninterface IHasActiveMembers {\\n  function isMemberActive(address member) external view returns(bool);\\n  function deactivateMember(address payable member) external;\\n  function activateMember(address member) external;\\n}\\n\",\"keccak256\":\"0x59859780a1d3a37c35d1dd2516434b170d49d044ef20918aa565703ab8f4a09a\",\"license\":\"MIT\"},\"contracts/interfaces/IHasGovernors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\ninterface IHasGovernors {\\n  function isGovernor(address governor) external view returns(bool);\\n  function governorCount() external view returns(uint256);\\n  function paginateGovernors(uint256 index, uint256 perPage) external view returns(address[] memory, uint256);\\n  function addGovernor(address payable governor) external;\\n  function removeGovernor(address governor) external;\\n}\\n\",\"keccak256\":\"0x87c9cb1f7f829c1197834d12eb05763217b0b56be530f1ab6fe0ded4500b5dd0\",\"license\":\"MIT\"},\"contracts/interfaces/IHasMembers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\ninterface IHasMembers {\\n  function isMember(address member) external view returns(bool);\\n  function memberCount() external view returns(uint256);\\n  function paginateMembers(uint256 index, uint256 perPage) external view returns(address[] memory, uint256);\\n  function addMember(address payable member) external;\\n  function removeMember(address member) external;\\n}\\n\",\"keccak256\":\"0x41cfdd80b0ab31a1e0a00f65cae19690aab7917b2c61faa7f7f478771e9a28ae\",\"license\":\"MIT\"},\"contracts/lib/LibAddressSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\nlibrary LibAddressSet {\\n  /// @dev Represents a list of addresses.\\n  struct Data {\\n    mapping(address => uint256) indices;\\n    address[] values;\\n  }\\n\\n  /**\\n   * @dev Adds an item into the storage set. If the address already exists in the\\n   *      set, the function reverts.\\n   * @param d is the internal data storage to use.\\n   * @param key is the address to be added.\\n   */\\n  function add(Data storage d, address key, bool noThrow)\\n      internal {\\n    bool exists = contains(d, key);\\n    if (noThrow && exists) { return; }\\n    require(!exists, 'Address already in set');\\n    d.indices[key] = d.values.length;\\n    d.values.push(key);\\n  }\\n\\n  /**\\n   * @dev Removes an item from the storage set. If the address does not exist in the\\n   *      set, the function reverts.\\n   * @param d is the internal data storage to use.\\n   * @param key is the address to be removed.\\n   */\\n  function remove(Data storage d, address key, bool noThrow)\\n      internal {\\n    bool exists = contains(d, key);\\n    if (noThrow && !exists) { return; }\\n    require(exists, 'Address does not exist in set');\\n    uint256 lastIndex = d.values.length - 1;\\n    address keyToMove = d.values[lastIndex];\\n    uint256 idxToReplace = d.indices[key];\\n    d.indices[keyToMove] = idxToReplace;\\n    d.values[idxToReplace] = keyToMove;\\n    delete d.indices[key];\\n    d.values.pop();\\n  }\\n\\n  /**\\n   * @dev Tests whether or not a given item already exists in the set.\\n   * @param d is the internal data storage to use.\\n   * @param key is the address to test.\\n   * @return a boolean.\\n   */\\n  function contains(Data storage d, address key)\\n      internal view returns(bool) {\\n    return d.values.length == 0\\n      ? false\\n      : d.values[d.indices[key]] == key;\\n  }\\n}\\n\",\"keccak256\":\"0x7daf050d0864e085c227521b1157b4ea652fe75ea7e10f685027b42d6e1caf87\",\"license\":\"MIT\"},\"contracts/lib/LibConstants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\nlibrary LibConstants {\\n  address internal constant ZERO_ADDRESS = address(0);\\n  address internal constant DEPLOYER_CONTRACT = 0x6DF2D25d8C6FD680730ee658b530A05a99BB769a;\\n\\n  string internal constant ALREADY_INITIALIZED = 'Already initialized';\\n  string internal constant INTERNAL_METHOD = 'Internal method';\\n  string internal constant REQUIRES_DIAMOND_OWNERSHIP = 'Requires diamond ownership';\\n  string internal constant REQUIRES_FAST_CONTRACT_CALLER = 'Caller must be a FAST contract';\\n\\n  string internal constant REQUIRES_SPC_MEMBERSHIP = 'Requires SPC membership';\\n  string internal constant REQUIRES_EXCHANGE_MEMBERSHIP = 'Requires Exchange membership';\\n  string internal constant REQUIRES_EXCHANGE_ACTIVE_MEMBER = 'Requires active Exchange member';\\n  string internal constant REQUIRES_EXCHANGE_DEACTIVATED_MEMBER = 'Requires a deactivated Exchange member';\\n\\n  string internal constant REQUIRES_FAST_GOVERNORSHIP = 'Requires FAST governorship';\\n  string internal constant REQUIRES_FAST_MEMBERSHIP = 'Requires FAST membership';\\n  string internal constant REQUIRES_NO_FAST_MEMBERSHIPS = 'Member still part of at least one FAST';\\n\\n  string internal constant DUPLICATE_ENTRY = 'Duplicate entry';\\n  string internal constant UNSUPPORTED_OPERATION = 'Unsupported operation';\\n  string internal constant REQUIRES_NON_ZERO_ADDRESS = 'Requires non-zero address';\\n  string internal constant REQUIRES_NON_CONTRACT_ADDR = 'Address cannot be a contract';\\n\\n  string internal constant MISSING_ATTACHED_ETH = 'Missing attached ETH';\\n\\n  string internal constant REQUIRES_CONTINUOUS_SUPPLY = 'Requires continuous supply';\\n  string internal constant INSUFFICIENT_FUNDS = 'Insufficient token balance';\\n  string internal constant INSUFFICIENT_ALLOWANCE = 'Insufficient allowance';\\n  string internal constant INSUFFICIENT_TRANSFER_CREDITS = 'Insufficient transfer credits';\\n  string internal constant REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT = 'Requires different sender and recipient';\\n  string internal constant UNKNOWN_RESTRICTION_CODE = 'Unknown restriction code';\\n}\\n\",\"keccak256\":\"0xb3fd352142cec908fdb78eadd41eb77db8bb1680b38599bc40197b51c013c951\",\"license\":\"MIT\"},\"contracts/lib/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);            \\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }    \\n\\n\\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n        // an immutable function is a function defined directly in a diamond\\n        require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x1c1bcc2f4ce958b3569ec95530879a584e4cf837d585a5059b3b612ad4a71a47\",\"license\":\"MIT\"},\"contracts/lib/LibHelpers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nlibrary LibHelpers {\\n  function upTo(address payable to, uint256 amount)\\n      internal view returns(uint256) {\\n    // If the recipient has more than what is ought to be paid, return.\\n    uint256 toBalance = to.balance;\\n    if (toBalance >= amount) { return 0; }\\n    // If the recipient has some Eth we should only pay the top-up.\\n    amount = amount - toBalance;\\n    // If the available eth is less than what we should pay, just cap it.\\n    uint256 available = payable(address(this)).balance;\\n    if (available < amount) { amount = available; }\\n    // Provision the new fast with Eth.\\n    return amount;\\n  }\\n\\n  function isContract(address target)\\n      internal view returns (bool) {\\n    uint32 size;\\n    assembly { size := extcodesize(target) }\\n    return (size > 0);\\n  }\\n}\\n\",\"keccak256\":\"0xa3ac21d8e6e5f25d9125d2975e7157e5c660bd481fb102c39a64810955d6eaab\",\"license\":\"MIT\"},\"contracts/lib/LibPaginate.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../fast/lib/LibFastHistory.sol';\\n\\n\\nlibrary LibPaginate {\\n  function addresses(address[] storage collection, uint256 cursor, uint256 perPage)\\n    internal view returns(address[] memory, uint256) {\\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n      address[] memory values = new address[](length);\\n      for (uint256 i = 0; i < length; i++) {\\n        values[i] = collection[cursor + i];\\n      }\\n      return (values, cursor + length);\\n  }\\n\\n  function uint256s(uint256[] storage collection, uint256 cursor, uint256 perPage)\\n    internal view returns(uint256[] memory, uint256) {\\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n      uint256[] memory values = new uint256[](length);\\n      for (uint256 i = 0; i < length; i++) {\\n        values[i] = collection[cursor + i];\\n      }\\n      return (values, cursor + length);\\n  }\\n\\n  function supplyProofs(LibFastHistory.SupplyProof[] storage collection, uint256 cursor, uint256 perPage)\\n    internal view returns(LibFastHistory.SupplyProof[] memory, uint256) {\\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n      LibFastHistory.SupplyProof[] memory values = new LibFastHistory.SupplyProof[](length);\\n      for (uint256 i = 0; i < length; i++) {\\n        values[i] = collection[cursor + i];\\n      }\\n      return (values, cursor + length);\\n  }\\n\\n  function transferProofs(LibFastHistory.TransferProof[] storage collection, uint256 cursor, uint256 perPage)\\n    internal view returns(LibFastHistory.TransferProof[] memory, uint256) {\\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n      LibFastHistory.TransferProof[] memory values = new LibFastHistory.TransferProof[](length);\\n      for (uint256 i = 0; i < length; i++) {\\n        values[i] = collection[cursor + i];\\n      }\\n      return (values, cursor + length);\\n  }\\n}\",\"keccak256\":\"0xedbf24531aa1b21a17a7962b2053fe1bd81ddf9e8869f508f14f7fb9087631d9\",\"license\":\"MIT\"},\"contracts/spc/SpcTopFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport '../lib/LibHelpers.sol';\\nimport '../fast/FastTopFacet.sol';\\nimport '../fast/FastTokenFacet.sol';\\nimport './lib/ASpcFacet.sol';\\nimport './lib/LibSpc.sol';\\n\\n\\ncontract SpcTopFacet is ASpcFacet {\\n  using LibAddressSet for LibAddressSet.Data;\\n  // Constants.\\n\\n  // This represents how much Eth we provision new SPC members with.\\n  uint256 constant private MEMBER_ETH_PROVISION = 10 ether;\\n  // This represents how much Eth new FASTs are provisioned with.\\n  uint256 constant private FAST_ETH_PROVISION = 250 ether;\\n\\n  // Eth provisioning stuff.\\n\\n  /** @dev A function that alllows provisioning this SPC with Eth.\\n   *  @notice Emits a `EthReceived` event.\\n   */\\n  function provisionWithEth()\\n      external payable {\\n    require(msg.value > 0, LibConstants.MISSING_ATTACHED_ETH);\\n    emit EthReceived(msg.sender, msg.value);\\n  }\\n\\n  /** @dev A function that alllows draining this SPC from its Eth.\\n   *  @notice Requires that the caller is a member of this SPC.\\n   *  @notice Emits a `EthDrained` event.\\n   */\\n  function drainEth()\\n      onlyMember(msg.sender) nonContract(msg.sender)\\n      external {\\n    uint256 amount = payable(address(this)).balance;\\n    payable(msg.sender).transfer(amount);\\n    emit EthDrained(msg.sender, amount);\\n  }\\n\\n  // FAST management related methods.\\n\\n  /** @dev Queries whether a given address is a known and registered FAST contract.\\n   * @param fast The address of the contract to check.\\n   * @return A boolean.\\n   */\\n  function isFastRegistered(address fast)\\n      external view returns(bool) {\\n    return LibSpc.data().fastSet.contains(fast);\\n  }\\n\\n  /** @dev Allows to retrieve the address of a FAST diamond given its symbol.\\n   *  @param symbol The symbol of the FAST diamond to get the address of.\\n   *  @return The address of the corresponding FAST diamond, or the Zero Address if not found.\\n   */\\n  function fastBySymbol(string calldata symbol)\\n      external view returns(address) {\\n    return LibSpc.data().fastSymbols[symbol];\\n  }\\n\\n  /** @dev Allows the registration of a given FAST diamond with this SPC.\\n   *  @param fast The address of the FAST diamond to be registered.\\n   *  @notice Requires that the caller is a member of this SPC.\\n   *  @notice Emits a `FastRegistered` event.\\n   */\\n  function registerFast(address fast)\\n      external\\n      onlyMember(msg.sender) {\\n    LibSpc.Data storage s = LibSpc.data();\\n    string memory symbol = FastTokenFacet(fast).symbol();\\n    require(s.fastSymbols[symbol] == address(0), LibConstants.DUPLICATE_ENTRY);\\n\\n    // Add the FAST to our list.\\n    s.fastSet.add(fast, false);\\n    // Add the fast symbol to our list.\\n    s.fastSymbols[symbol] = fast;\\n\\n    // Provision the new fast with Eth.\\n    uint256 amount = LibHelpers.upTo(payable(fast), FAST_ETH_PROVISION);\\n    // Only provision the fast if possible.\\n    if (amount > 0) {\\n      FastTopFacet(fast).provisionWithEth{ value: amount }();\\n    }\\n    // Emit!\\n    emit FastRegistered(fast);\\n  }\\n\\n  /** @dev Counts the number of FAST diamonds registered with this SPC.\\n   *  @return The number of FAST diamonds registered with this SPC.\\n   */\\n  function fastCount()\\n      external view returns(uint256) {\\n    return LibSpc.data().fastSet.values.length;\\n  }\\n\\n  /** @dev Paginates the FAST diamonds registered with this SPC based on a starting cursor and a number of records per page.\\n   *  @param cursor The index at which to start.\\n   *  @param perPage How many records should be returned at most.\\n   *  @return A `address[]` list of values at most `perPage` big.\\n   *  @return A `uint256` index to the next page.\\n   */\\n  function paginateFasts(uint256 cursor, uint256 perPage)\\n      external view\\n      returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibSpc.data().fastSet.values, cursor, perPage);\\n  }\\n}\\n\",\"keccak256\":\"0xe28d5ccc9649d2caf46ff63b458cad8b39ca4b985c9d4c7cac3274d2b35211fb\",\"license\":\"MIT\"},\"contracts/spc/lib/ASpcFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibConstants.sol';\\nimport '../../lib/LibHelpers.sol';\\nimport '../../lib/LibAddressSet.sol';\\nimport '../../interfaces/IERC173.sol';\\nimport '../lib/LibSpcAccess.sol';\\nimport './ISpcEvents.sol';\\n\\n\\n/**\\n* @dev This contract is a group of modifiers that can be used by any facets to guard against\\n*       certain permissions.\\n*/\\nabstract contract ASpcFacet is ISpcEvents {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  /// Modifiers.\\n\\n  /// @dev Ensures that a method can only be called by another facet of the same diamond.\\n  modifier onlyDiamondFacet() {\\n    require(\\n      msg.sender == address(this),\\n      LibConstants.INTERNAL_METHOD\\n    );\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the owner of this diamond.\\n  modifier onlyDiamondOwner() {\\n    require(\\n      msg.sender == IERC173(address(this)).owner(),\\n      LibConstants.REQUIRES_DIAMOND_OWNERSHIP\\n    );\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is **not** a contract.\\n   *  @param candidate The address to check.\\n   */\\n  modifier nonContract(address candidate) {\\n    require(\\n      !LibHelpers.isContract(candidate),\\n      LibConstants.REQUIRES_NON_CONTRACT_ADDR\\n    );\\n    _;\\n  }\\n\\n  /// @dev Ensures that the given address is a member of the current FAST.\\n  modifier onlyMember(address candidate) {\\n    require(\\n      LibSpcAccess.data().memberSet.contains(candidate),\\n      LibConstants.REQUIRES_SPC_MEMBERSHIP\\n    );\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x597f077c6e26ad90904b1a1d11f5d1d2bc8525b568e98ba492171292b0f5e79d\",\"license\":\"MIT\"},\"contracts/spc/lib/ISpcEvents.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\n// WARNING: These events must be maintained 1:1 with LibSpcEvents!\\n// They also should never be emitted directly, they only help us defining\\n// typescript types!\\ninterface ISpcEvents {\\n  // ETH provisioning events.\\n\\n  /** @dev Emited when someone provisions this SPC with Eth.\\n   *  @param from The sender of the Eth.\\n   *  @param amount The quantity of Eth, expressed in Wei.\\n   */\\n  event EthReceived(address indexed from, uint256 amount);\\n  /** @dev Emited when Eth is drained from this SPC.\\n   *  @param to The caller and recipient of the drained Eth.\\n   *  @param amount The quantity of Eth that was drained, expressed in Wei.\\n   */\\n  event EthDrained(address indexed to, uint256 amount);\\n\\n  // Fast registration events.\\n\\n  /** @dev Emited when a new FAST is registered.\\n   *  @param fast The address of the newly registered FAST diamond.\\n   */\\n  event FastRegistered(address indexed fast);\\n\\n  // IHasMembers.\\n\\n  event MemberAdded(address indexed member);\\n  event MemberRemoved(address indexed member);\\n}\\n\",\"keccak256\":\"0x27e66d85fba410948f2430af4ea6625c4e9ddb67d1e51db29a52fada896d9f82\",\"license\":\"MIT\"},\"contracts/spc/lib/LibSpc.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\n\\nlibrary LibSpc {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Spc.storage'):\\n  bytes32 internal constant STORAGE_SLOT = 0x89a652f66ca129ef71cab44916bb070742a08af428e08a99df145c8006c94285;\\n\\n  // Data structures.\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    // This is where we keep our list of deployed fast FASTs.\\n    LibAddressSet.Data fastSet;\\n    // We keep track of the FAST symbols that were already used.\\n    mapping(string => address) fastSymbols;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0x2f1607e60e30bf54c0837ccd996c6266836284ff6f40d1618b93f735d5d86157\",\"license\":\"MIT\"},\"contracts/spc/lib/LibSpcAccess.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\n\\nlibrary LibSpcAccess {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Spc.storage.Access'):\\n  bytes32 internal constant STORAGE_SLOT = 0xe275f58a6a7f532ee3fa7fff24450c253df494fca407d91f5c35e83236f64d7c;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    // This is where we hold our members data.\\n    LibAddressSet.Data memberSet;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0x29d45304060a54f75b7dfbaada867418c97bac21dd484ac6c777b33f3628eb35\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50611e23806100206000396000f3fe608060405234801561001057600080fd5b50600436106100a95760003560e01c80638f7fba5b116100715780638f7fba5b14610150578063a230c52414610181578063af827ff7146101b1578063c6549ba4146101cd578063ca6d56dc146101fe578063d4f3476d1461021a576100a9565b80630b1ca49a146100ae57806311aee380146100ca5780631b09a281146100e8578063673176471461010457806378ab262e14610134575b600080fd5b6100c860048036038101906100c39190611784565b610236565b005b6100d2610474565b6040516100df9190611aad565b60405180910390f35b61010260048036038101906100fd9190611784565b61048d565b005b61011e60048036038101906101199190611784565b61061f565b60405161012b9190611a30565b60405180910390f35b61014e60048036038101906101499190611784565b610646565b005b61016a600480360381019061016591906117d6565b610954565b604051610178929190611a00565b60405180910390f35b61019b60048036038101906101969190611784565b6109b9565b6040516101a89190611a30565b60405180910390f35b6101cb60048036038101906101c69190611784565b6109df565b005b6101e760048036038101906101e2919061184e565b610b71565b6040516101f5929190611a00565b60405180910390f35b610218600480360381019061021391906117ad565b610b98565b005b610234600480360381019061022f91906117ad565b610d2a565b005b61023e611054565b60000160029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a230c524336040518263ffffffff1660e01b815260040161029a91906119ca565b60206040518083038186803b1580156102b257600080fd5b505afa1580156102c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102ea9190611825565b6040518060400160405280601781526020017f526571756972657320535043206d656d6265727368697000000000000000000081525090610361576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103589190611a4b565b60405180910390fd5b50600061036c61107c565b905060008160030160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206001018054905014604051806060016040528060268152602001611dc86026913990610413576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161040a9190611a4b565b60405180910390fd5b5061042d826000836001016110a49092919063ffffffff16565b8173ffffffffffffffffffffffffffffffffffffffff167f6e76fb4c77256006d9c38ec7d82b45a8c8f3c27b1d6766fffc42dfb8de68449260405160405180910390a25050565b600061047e61107c565b60010160010180549050905090565b610495611054565b60000160029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166341d7c02d336040518263ffffffff1660e01b81526004016104f191906119ca565b60206040518083038186803b15801561050957600080fd5b505afa15801561051d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105419190611825565b6040518060400160405280601e81526020017f43616c6c6572206d7573742062652061204641535420636f6e74726163740000815250906105b8576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105af9190611a4b565b60405180910390fd5b5060006105c361107c565b60030160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905061061b336000836110a49092919063ffffffff16565b5050565b600061063e8261062d61107c565b60040161135a90919063ffffffff16565b159050919050565b61064e611054565b60000160029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a230c524336040518263ffffffff1660e01b81526004016106aa91906119ca565b60206040518083038186803b1580156106c257600080fd5b505afa1580156106d6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106fa9190611825565b6040518060400160405280601781526020017f526571756972657320535043206d656d6265727368697000000000000000000081525090610771576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016107689190611a4b565b60405180910390fd5b50806107908161077f61107c565b60010161135a90919063ffffffff16565b6040518060400160405280601c81526020017f52657175697265732045786368616e6765206d656d626572736869700000000081525090610807576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016107fe9190611a4b565b60405180910390fd5b503073ffffffffffffffffffffffffffffffffffffffff166367317647836040518263ffffffff1660e01b815260040161084191906119ca565b60206040518083038186803b15801561085957600080fd5b505afa15801561086d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108919190611825565b15604051806060016040528060268152602001611da260269139906108ec576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016108e39190611a4b565b60405180910390fd5b5061090d8260006108fb61107c565b6004016110a49092919063ffffffff16565b8173ffffffffffffffffffffffffffffffffffffffff167f9b0dfddc7b811f70aa2c63314554f36c3be80f3a490db1ee566c6ae5b9e0497060405160405180910390a25050565b606060006109ad61096361107c565b60030160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206001018585611450565b91509150935093915050565b60006109d8826109c761107c565b60010161135a90919063ffffffff16565b9050919050565b6109e7611054565b60000160029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166341d7c02d336040518263ffffffff1660e01b8152600401610a4391906119ca565b60206040518083038186803b158015610a5b57600080fd5b505afa158015610a6f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a939190611825565b6040518060400160405280601e81526020017f43616c6c6572206d7573742062652061204641535420636f6e7472616374000081525090610b0a576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b019190611a4b565b60405180910390fd5b506000610b1561107c565b60030160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000209050610b6d336000836116139092919063ffffffff16565b5050565b60606000610b8d610b8061107c565b6001016001018585611450565b915091509250929050565b610ba0611054565b60000160029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a230c524336040518263ffffffff1660e01b8152600401610bfc91906119ca565b60206040518083038186803b158015610c1457600080fd5b505afa158015610c28573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c4c9190611825565b6040518060400160405280601781526020017f526571756972657320535043206d656d6265727368697000000000000000000081525090610cc3576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610cba9190611a4b565b60405180910390fd5b50610ce4816000610cd261107c565b6001016116139092919063ffffffff16565b8073ffffffffffffffffffffffffffffffffffffffff167fb251eb052afc73ffd02ffe85ad79990a8b3fed60d76dbc2fa2fdd7123dffd91460405160405180910390a250565b610d32611054565b60000160029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a230c524336040518263ffffffff1660e01b8152600401610d8e91906119ca565b60206040518083038186803b158015610da657600080fd5b505afa158015610dba573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dde9190611825565b6040518060400160405280601781526020017f526571756972657320535043206d656d6265727368697000000000000000000081525090610e55576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610e4c9190611a4b565b60405180910390fd5b5080610e7481610e6361107c565b60010161135a90919063ffffffff16565b6040518060400160405280601c81526020017f52657175697265732045786368616e6765206d656d626572736869700000000081525090610eeb576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ee29190611a4b565b60405180910390fd5b503073ffffffffffffffffffffffffffffffffffffffff166367317647836040518263ffffffff1660e01b8152600401610f2591906119e5565b60206040518083038186803b158015610f3d57600080fd5b505afa158015610f51573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f759190611825565b6040518060400160405280601f81526020017f5265717569726573206163746976652045786368616e6765206d656d6265720081525090610fec576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610fe39190611a4b565b60405180910390fd5b5061100d826000610ffb61107c565b6004016116139092919063ffffffff16565b8173ffffffffffffffffffffffffffffffffffffffff167fd09c98686577f18c498d909faf17eff8fa165d9f4e25dce055e78cf7fb95cc1d60405160405180910390a25050565b60007f58cca9481e011ced58c1d520ef5aad456e5805265d66de8df7c52f680c417394905090565b60007f238f5ead2481aef1ec60acdfe5b3de34c076d0a86bb41e30c913f5f3885d7c47905090565b60006110b0848461135a565b90508180156110bd575080155b156110c85750611355565b80611108576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016110ff90611a8d565b60405180910390fd5b60006001856001018054905061111e9190611b73565b9050600085600101828154811061115e577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905060008660000160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050808760000160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555081876001018281548110611254577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508660000160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600090558660010180548061131b577f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fd5b6001900381819060005260206000200160006101000a81549073ffffffffffffffffffffffffffffffffffffffff02191690559055505050505b505050565b600080836001018054905014611445578173ffffffffffffffffffffffffffffffffffffffff16836001018460000160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054815481106113fe577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614611448565b60005b905092915050565b60606000808486805490506114659190611b73565b84116114715783611482565b8486805490506114819190611b73565b5b905060008167ffffffffffffffff8111156114c6577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280602002602001820160405280156114f45781602001602082028036833780820191505090505b50905060005b828110156115f75787818861150f9190611b1d565b81548110611546577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168282815181106115aa577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505080806115ef90611c6a565b9150506114fa565b508082876116059190611b1d565b935093505050935093915050565b600061161f848461135a565b905081801561162b5750805b15611636575061172b565b8015611677576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161166e90611a6d565b60405180910390fd5b83600101805490508460000160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555083600101839080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550505b505050565b60008135905061173f81611d45565b92915050565b60008135905061175481611d5c565b92915050565b60008151905061176981611d73565b92915050565b60008135905061177e81611d8a565b92915050565b60006020828403121561179657600080fd5b60006117a484828501611730565b91505092915050565b6000602082840312156117bf57600080fd5b60006117cd84828501611745565b91505092915050565b6000806000606084860312156117eb57600080fd5b60006117f986828701611730565b935050602061180a8682870161176f565b925050604061181b8682870161176f565b9150509250925092565b60006020828403121561183757600080fd5b60006118458482850161175a565b91505092915050565b6000806040838503121561186157600080fd5b600061186f8582860161176f565b92505060206118808582860161176f565b9150509250929050565b600061189683836118b1565b60208301905092915050565b6118ab81611c01565b82525050565b6118ba81611ba7565b82525050565b6118c981611ba7565b82525050565b60006118da82611ad8565b6118e48185611afb565b93506118ef83611ac8565b8060005b83811015611920578151611907888261188a565b975061191283611aee565b9250506001810190506118f3565b5085935050505092915050565b61193681611bcb565b82525050565b600061194782611ae3565b6119518185611b0c565b9350611961818560208601611c37565b61196a81611ce2565b840191505092915050565b6000611982601683611b0c565b915061198d82611cf3565b602082019050919050565b60006119a5601d83611b0c565b91506119b082611d1c565b602082019050919050565b6119c481611bf7565b82525050565b60006020820190506119df60008301846118c0565b92915050565b60006020820190506119fa60008301846118a2565b92915050565b60006040820190508181036000830152611a1a81856118cf565b9050611a2960208301846119bb565b9392505050565b6000602082019050611a45600083018461192d565b92915050565b60006020820190508181036000830152611a65818461193c565b905092915050565b60006020820190508181036000830152611a8681611975565b9050919050565b60006020820190508181036000830152611aa681611998565b9050919050565b6000602082019050611ac260008301846119bb565b92915050565b6000819050602082019050919050565b600081519050919050565b600081519050919050565b6000602082019050919050565b600082825260208201905092915050565b600082825260208201905092915050565b6000611b2882611bf7565b9150611b3383611bf7565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115611b6857611b67611cb3565b5b828201905092915050565b6000611b7e82611bf7565b9150611b8983611bf7565b925082821015611b9c57611b9b611cb3565b5b828203905092915050565b6000611bb282611bd7565b9050919050565b6000611bc482611bd7565b9050919050565b60008115159050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b6000611c0c82611c13565b9050919050565b6000611c1e82611c25565b9050919050565b6000611c3082611bd7565b9050919050565b60005b83811015611c55578082015181840152602081019050611c3a565b83811115611c64576000848401525b50505050565b6000611c7582611bf7565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821415611ca857611ca7611cb3565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000601f19601f8301169050919050565b7f4164647265737320616c726561647920696e2073657400000000000000000000600082015250565b7f4164647265737320646f6573206e6f7420657869737420696e20736574000000600082015250565b611d4e81611ba7565b8114611d5957600080fd5b50565b611d6581611bb9565b8114611d7057600080fd5b50565b611d7c81611bcb565b8114611d8757600080fd5b50565b611d9381611bf7565b8114611d9e57600080fd5b5056fe526571756972657320612064656163746976617465642045786368616e6765206d656d6265724d656d626572207374696c6c2070617274206f66206174206c65617374206f6e652046415354a26469706673582212209829f0d2c5f33122fa15674a581f79708d42122d329946d9b2cd206f483e4af864736f6c63430008040033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100a95760003560e01c80638f7fba5b116100715780638f7fba5b14610150578063a230c52414610181578063af827ff7146101b1578063c6549ba4146101cd578063ca6d56dc146101fe578063d4f3476d1461021a576100a9565b80630b1ca49a146100ae57806311aee380146100ca5780631b09a281146100e8578063673176471461010457806378ab262e14610134575b600080fd5b6100c860048036038101906100c39190611784565b610236565b005b6100d2610474565b6040516100df9190611aad565b60405180910390f35b61010260048036038101906100fd9190611784565b61048d565b005b61011e60048036038101906101199190611784565b61061f565b60405161012b9190611a30565b60405180910390f35b61014e60048036038101906101499190611784565b610646565b005b61016a600480360381019061016591906117d6565b610954565b604051610178929190611a00565b60405180910390f35b61019b60048036038101906101969190611784565b6109b9565b6040516101a89190611a30565b60405180910390f35b6101cb60048036038101906101c69190611784565b6109df565b005b6101e760048036038101906101e2919061184e565b610b71565b6040516101f5929190611a00565b60405180910390f35b610218600480360381019061021391906117ad565b610b98565b005b610234600480360381019061022f91906117ad565b610d2a565b005b61023e611054565b60000160029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a230c524336040518263ffffffff1660e01b815260040161029a91906119ca565b60206040518083038186803b1580156102b257600080fd5b505afa1580156102c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102ea9190611825565b6040518060400160405280601781526020017f526571756972657320535043206d656d6265727368697000000000000000000081525090610361576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103589190611a4b565b60405180910390fd5b50600061036c61107c565b905060008160030160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206001018054905014604051806060016040528060268152602001611dc86026913990610413576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161040a9190611a4b565b60405180910390fd5b5061042d826000836001016110a49092919063ffffffff16565b8173ffffffffffffffffffffffffffffffffffffffff167f6e76fb4c77256006d9c38ec7d82b45a8c8f3c27b1d6766fffc42dfb8de68449260405160405180910390a25050565b600061047e61107c565b60010160010180549050905090565b610495611054565b60000160029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166341d7c02d336040518263ffffffff1660e01b81526004016104f191906119ca565b60206040518083038186803b15801561050957600080fd5b505afa15801561051d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105419190611825565b6040518060400160405280601e81526020017f43616c6c6572206d7573742062652061204641535420636f6e74726163740000815250906105b8576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105af9190611a4b565b60405180910390fd5b5060006105c361107c565b60030160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905061061b336000836110a49092919063ffffffff16565b5050565b600061063e8261062d61107c565b60040161135a90919063ffffffff16565b159050919050565b61064e611054565b60000160029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a230c524336040518263ffffffff1660e01b81526004016106aa91906119ca565b60206040518083038186803b1580156106c257600080fd5b505afa1580156106d6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106fa9190611825565b6040518060400160405280601781526020017f526571756972657320535043206d656d6265727368697000000000000000000081525090610771576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016107689190611a4b565b60405180910390fd5b50806107908161077f61107c565b60010161135a90919063ffffffff16565b6040518060400160405280601c81526020017f52657175697265732045786368616e6765206d656d626572736869700000000081525090610807576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016107fe9190611a4b565b60405180910390fd5b503073ffffffffffffffffffffffffffffffffffffffff166367317647836040518263ffffffff1660e01b815260040161084191906119ca565b60206040518083038186803b15801561085957600080fd5b505afa15801561086d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108919190611825565b15604051806060016040528060268152602001611da260269139906108ec576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016108e39190611a4b565b60405180910390fd5b5061090d8260006108fb61107c565b6004016110a49092919063ffffffff16565b8173ffffffffffffffffffffffffffffffffffffffff167f9b0dfddc7b811f70aa2c63314554f36c3be80f3a490db1ee566c6ae5b9e0497060405160405180910390a25050565b606060006109ad61096361107c565b60030160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206001018585611450565b91509150935093915050565b60006109d8826109c761107c565b60010161135a90919063ffffffff16565b9050919050565b6109e7611054565b60000160029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166341d7c02d336040518263ffffffff1660e01b8152600401610a4391906119ca565b60206040518083038186803b158015610a5b57600080fd5b505afa158015610a6f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a939190611825565b6040518060400160405280601e81526020017f43616c6c6572206d7573742062652061204641535420636f6e7472616374000081525090610b0a576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b019190611a4b565b60405180910390fd5b506000610b1561107c565b60030160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000209050610b6d336000836116139092919063ffffffff16565b5050565b60606000610b8d610b8061107c565b6001016001018585611450565b915091509250929050565b610ba0611054565b60000160029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a230c524336040518263ffffffff1660e01b8152600401610bfc91906119ca565b60206040518083038186803b158015610c1457600080fd5b505afa158015610c28573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c4c9190611825565b6040518060400160405280601781526020017f526571756972657320535043206d656d6265727368697000000000000000000081525090610cc3576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610cba9190611a4b565b60405180910390fd5b50610ce4816000610cd261107c565b6001016116139092919063ffffffff16565b8073ffffffffffffffffffffffffffffffffffffffff167fb251eb052afc73ffd02ffe85ad79990a8b3fed60d76dbc2fa2fdd7123dffd91460405160405180910390a250565b610d32611054565b60000160029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a230c524336040518263ffffffff1660e01b8152600401610d8e91906119ca565b60206040518083038186803b158015610da657600080fd5b505afa158015610dba573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dde9190611825565b6040518060400160405280601781526020017f526571756972657320535043206d656d6265727368697000000000000000000081525090610e55576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610e4c9190611a4b565b60405180910390fd5b5080610e7481610e6361107c565b60010161135a90919063ffffffff16565b6040518060400160405280601c81526020017f52657175697265732045786368616e6765206d656d626572736869700000000081525090610eeb576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ee29190611a4b565b60405180910390fd5b503073ffffffffffffffffffffffffffffffffffffffff166367317647836040518263ffffffff1660e01b8152600401610f2591906119e5565b60206040518083038186803b158015610f3d57600080fd5b505afa158015610f51573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f759190611825565b6040518060400160405280601f81526020017f5265717569726573206163746976652045786368616e6765206d656d6265720081525090610fec576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610fe39190611a4b565b60405180910390fd5b5061100d826000610ffb61107c565b6004016116139092919063ffffffff16565b8173ffffffffffffffffffffffffffffffffffffffff167fd09c98686577f18c498d909faf17eff8fa165d9f4e25dce055e78cf7fb95cc1d60405160405180910390a25050565b60007f58cca9481e011ced58c1d520ef5aad456e5805265d66de8df7c52f680c417394905090565b60007f238f5ead2481aef1ec60acdfe5b3de34c076d0a86bb41e30c913f5f3885d7c47905090565b60006110b0848461135a565b90508180156110bd575080155b156110c85750611355565b80611108576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016110ff90611a8d565b60405180910390fd5b60006001856001018054905061111e9190611b73565b9050600085600101828154811061115e577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905060008660000160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050808760000160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555081876001018281548110611254577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508660000160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600090558660010180548061131b577f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fd5b6001900381819060005260206000200160006101000a81549073ffffffffffffffffffffffffffffffffffffffff02191690559055505050505b505050565b600080836001018054905014611445578173ffffffffffffffffffffffffffffffffffffffff16836001018460000160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054815481106113fe577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614611448565b60005b905092915050565b60606000808486805490506114659190611b73565b84116114715783611482565b8486805490506114819190611b73565b5b905060008167ffffffffffffffff8111156114c6577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280602002602001820160405280156114f45781602001602082028036833780820191505090505b50905060005b828110156115f75787818861150f9190611b1d565b81548110611546577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168282815181106115aa577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505080806115ef90611c6a565b9150506114fa565b508082876116059190611b1d565b935093505050935093915050565b600061161f848461135a565b905081801561162b5750805b15611636575061172b565b8015611677576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161166e90611a6d565b60405180910390fd5b83600101805490508460000160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555083600101839080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550505b505050565b60008135905061173f81611d45565b92915050565b60008135905061175481611d5c565b92915050565b60008151905061176981611d73565b92915050565b60008135905061177e81611d8a565b92915050565b60006020828403121561179657600080fd5b60006117a484828501611730565b91505092915050565b6000602082840312156117bf57600080fd5b60006117cd84828501611745565b91505092915050565b6000806000606084860312156117eb57600080fd5b60006117f986828701611730565b935050602061180a8682870161176f565b925050604061181b8682870161176f565b9150509250925092565b60006020828403121561183757600080fd5b60006118458482850161175a565b91505092915050565b6000806040838503121561186157600080fd5b600061186f8582860161176f565b92505060206118808582860161176f565b9150509250929050565b600061189683836118b1565b60208301905092915050565b6118ab81611c01565b82525050565b6118ba81611ba7565b82525050565b6118c981611ba7565b82525050565b60006118da82611ad8565b6118e48185611afb565b93506118ef83611ac8565b8060005b83811015611920578151611907888261188a565b975061191283611aee565b9250506001810190506118f3565b5085935050505092915050565b61193681611bcb565b82525050565b600061194782611ae3565b6119518185611b0c565b9350611961818560208601611c37565b61196a81611ce2565b840191505092915050565b6000611982601683611b0c565b915061198d82611cf3565b602082019050919050565b60006119a5601d83611b0c565b91506119b082611d1c565b602082019050919050565b6119c481611bf7565b82525050565b60006020820190506119df60008301846118c0565b92915050565b60006020820190506119fa60008301846118a2565b92915050565b60006040820190508181036000830152611a1a81856118cf565b9050611a2960208301846119bb565b9392505050565b6000602082019050611a45600083018461192d565b92915050565b60006020820190508181036000830152611a65818461193c565b905092915050565b60006020820190508181036000830152611a8681611975565b9050919050565b60006020820190508181036000830152611aa681611998565b9050919050565b6000602082019050611ac260008301846119bb565b92915050565b6000819050602082019050919050565b600081519050919050565b600081519050919050565b6000602082019050919050565b600082825260208201905092915050565b600082825260208201905092915050565b6000611b2882611bf7565b9150611b3383611bf7565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115611b6857611b67611cb3565b5b828201905092915050565b6000611b7e82611bf7565b9150611b8983611bf7565b925082821015611b9c57611b9b611cb3565b5b828203905092915050565b6000611bb282611bd7565b9050919050565b6000611bc482611bd7565b9050919050565b60008115159050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b6000611c0c82611c13565b9050919050565b6000611c1e82611c25565b9050919050565b6000611c3082611bd7565b9050919050565b60005b83811015611c55578082015181840152602081019050611c3a565b83811115611c64576000848401525b50505050565b6000611c7582611bf7565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821415611ca857611ca7611cb3565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000601f19601f8301169050919050565b7f4164647265737320616c726561647920696e2073657400000000000000000000600082015250565b7f4164647265737320646f6573206e6f7420657869737420696e20736574000000600082015250565b611d4e81611ba7565b8114611d5957600080fd5b50565b611d6581611bb9565b8114611d7057600080fd5b50565b611d7c81611bcb565b8114611d8757600080fd5b50565b611d9381611bf7565b8114611d9e57600080fd5b5056fe526571756972657320612064656163746976617465642045786368616e6765206d656d6265724d656d626572207374696c6c2070617274206f66206174206c65617374206f6e652046415354a26469706673582212209829f0d2c5f33122fa15674a581f79708d42122d329946d9b2cd206f483e4af864736f6c63430008040033",
  "devdoc": {
    "details": "The Exchange Access facet is in charge of keeping track of exchange members.",
    "kind": "dev",
    "methods": {
      "activateMember(address)": {
        "details": "Activates a member at the Exchange level.",
        "params": {
          "member": "The member to remove from the deactivation member set."
        }
      },
      "addMember(address)": {
        "details": "Adds a member to this Exchange member list.",
        "params": {
          "member": "is the address of the member to be added."
        }
      },
      "deactivateMember(address)": {
        "details": "Deactivates a member at the Exchange level.",
        "params": {
          "member": "The member to add to the deactivation member set."
        }
      },
      "fastMemberships(address,uint256,uint256)": {
        "details": "Allows to query FAST memberships for a given member address.",
        "params": {
          "cursor": "The index at which to start.",
          "member": "Is the address to check.",
          "perPage": "How many records should be returned at most."
        }
      },
      "isMember(address)": {
        "details": "Queries whether a given address is a member of this Exchange or not.",
        "params": {
          "candidate": "is the address to test."
        },
        "returns": {
          "_0": "A `boolean` flag."
        }
      },
      "isMemberActive(address)": {
        "details": "Given a member returns it's activation status.",
        "params": {
          "member": "The member to check activation status on."
        }
      },
      "memberAddedToFast(address)": {
        "details": "Callback from FAST contracts allowing the Exchange contract to keep track of FAST memberships.",
        "params": {
          "member": "The member for which a new FAST membership has been added."
        }
      },
      "memberCount()": {
        "details": "Counts the numbers of members present in this Exchange.",
        "returns": {
          "_0": "The number of members in this exchange."
        }
      },
      "memberRemovedFromFast(address)": {
        "details": "Callback from FAST contracts allowing the Exchange contract to keep track of FAST memberships.",
        "params": {
          "member": "The member for which a FAST membership has been removed."
        }
      },
      "paginateMembers(uint256,uint256)": {
        "details": "Paginates the members of this Exchange based on a starting cursor and a number of records per page.",
        "params": {
          "cursor": "is the index at which to start.",
          "perPage": "is how many records should be returned at most."
        },
        "returns": {
          "_0": "A `address[]` list of values at most `perPage` big.",
          "_1": "A `uint256` index to the next page."
        }
      },
      "removeMember(address)": {
        "details": "Removes a member from this Exchange.",
        "params": {
          "member": "is the address of the member to be removed."
        }
      }
    },
    "title": "The Exchange Smart Contract.",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "addMember(address)": {
        "notice": "Requires that the caller is a member of the linked SPC.Emits a `IHasMembers.MemberAdded` event."
      },
      "removeMember(address)": {
        "notice": "Requires that the caller is a member of the linked SPC.Emits a `IHasMembers.MemberRemoved` event."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}