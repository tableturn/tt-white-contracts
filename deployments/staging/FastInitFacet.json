{
  "address": "0xD150f78DA1B24dF04c87D6FE8f53812703541df3",
  "abi": [
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "spc",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "exchange",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "governor",
              "type": "address"
            },
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "symbol",
              "type": "string"
            },
            {
              "internalType": "uint256",
              "name": "decimals",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "hasFixedSupply",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "isSemiPublic",
              "type": "bool"
            }
          ],
          "internalType": "struct FastInitFacet.InitializerParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "ff01faa9007aa585a44363003101a726",
  "metadata": "{\"compiler\":{\"version\":\"0.8.4+commit.c7e474f2\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"spc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"governor\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasFixedSupply\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSemiPublic\",\"type\":\"bool\"}],\"internalType\":\"struct FastInitFacet.InitializerParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Note that although this contract doesn't explicitelly inherit from IERC173, ERC165, IDiamondLoupe etc, all       methods are in fact implemented by the underlaying Diamond proxy. It is therefore safe to       perform casts directly on the current contract address into these interfaces.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/fast/FastInitFacet.sol\":\"FastInitFacet\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/exchange/ExchangeTopFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport '../spc/SpcTopFacet.sol';\\nimport './lib/LibExchange.sol';\\nimport '../interfaces/IHasMembers.sol';\\nimport './lib/AExchangeFacet.sol';\\n\\n\\n/** @title The Exchange Smart Contract.\\n *  @dev The exchange facet is in charge of keeping track of exchange members and has logic\\n *  related to trading.\\n *  It requires an SPC contract instance at initialization-time, as it relies on SPC membership\\n *  to permission governance functions.\\n *  For now, the Exchange contract will only have one facet. Later on, we should split its\\n *  business logic into as many facets as we have domains.\\n */\\ncontract ExchangeTopFacet is AExchangeFacet, IHasMembers {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  // Getters.\\n\\n  function spcAddress()\\n    external view returns(address) {\\n      return LibExchange.data().spc;\\n  }\\n\\n  // Membership management.\\n\\n  /** @dev Queries whether a given address is a member of this Exchange or not.\\n   *  @param candidate is the address to test.\\n   *  @return A `boolean` flag.\\n   */\\n  function isMember(address candidate)\\n      external override view returns(bool) {\\n    return LibExchange.data().memberSet.contains(candidate);\\n  }\\n\\n  /** @dev Counts the numbers of members present in this Exchange.\\n   *  @return The number of members in this exchange.\\n   */\\n  function memberCount()\\n      external override view returns(uint256) {\\n    return LibExchange.data().memberSet.values.length;\\n  }\\n\\n  /** @dev Paginates the members of this Exchange based on a starting cursor and a number of records per page.\\n   *  @param cursor is the index at which to start.\\n   *  @param perPage is how many records should be returned at most.\\n   *  @return A `address[]` list of values at most `perPage` big.\\n   *  @return A `uint256` index to the next page.\\n   */\\n  function paginateMembers(uint256 cursor, uint256 perPage)\\n      external override view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibExchange.data().memberSet.values, cursor, perPage);\\n  }\\n\\n  /** @dev Adds a member to this Exchange member list.\\n   *  @param member is the address of the member to be added.\\n   *  @notice Requires that the caller is a member of the linked SPC.\\n   *  @notice Emits a `IHasMembers.MemberAdded` event.\\n   */\\n  function addMember(address payable member)\\n      external override\\n      spcMembership(msg.sender) {\\n    // Add the member to our list.\\n    LibExchange.data().memberSet.add(member, false);\\n    // Emit!\\n    emit IHasMembers.MemberAdded(member);\\n  }\\n\\n  /** @dev Removes a member from this Exchange.\\n   *  @param member is the address of the member to be removed.\\n   *  @notice Requires that the caller is a member of the linked SPC.\\n   *  @notice Emits a `IHasMembers.MemberRemoved` event.\\n   */\\n  function removeMember(address member)\\n      external override\\n      spcMembership(msg.sender) {\\n    LibExchange.Data storage s = LibExchange.data();\\n    // Ensure that member doesn't have any FAST membership.\\n    require(s.fastMemberships[member].values.length == 0, LibConstants.REQUIRES_NO_FAST_MEMBERSHIPS);\\n    // Remove member.\\n    s.memberSet.remove(member, false);\\n    // Emit!\\n    emit IHasMembers.MemberRemoved(member);\\n  }\\n\\n  /** @dev Allows to query FAST memberships for a given member address.\\n   *  @param member Is the address to check.\\n   *  @param cursor The index at which to start.\\n   *  @param perPage How many records should be returned at most.\\n   */\\n  function fastMemberships(address member, uint256 cursor, uint256 perPage)\\n      external view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibExchange.data().fastMemberships[member].values, cursor, perPage);\\n  }\\n\\n  /** @dev Callback from FAST contracts allowing the Exchange contract to keep track of FAST memberships.\\n   *  @param member The member for which a new FAST membership has been added.\\n   */\\n  function memberAddedToFast(address member) \\n      external {\\n    LibExchange.Data storage s = LibExchange.data();\\n    // Verify that the given address is in fact a registered FAST contract.\\n    require(SpcTopFacet(s.spc).isFastRegistered(msg.sender), LibConstants.REQUIRES_FAST_CONTRACT_CALLER);\\n    // Keep track of the member's FAST membership.\\n    LibAddressSet.Data storage memberFasts = s.fastMemberships[member];\\n    memberFasts.add(msg.sender, false);\\n  }\\n\\n  /** @dev Callback from FAST contracts allowing the Exchange contract to keep track of FAST memberships.\\n   *  @param member The member for which a FAST membership has been removed.\\n   */\\n  function memberRemovedFromFast(address member)\\n      external {\\n    LibExchange.Data storage s = LibExchange.data();\\n    require(SpcTopFacet(s.spc).isFastRegistered(msg.sender), LibConstants.REQUIRES_FAST_CONTRACT_CALLER);\\n    // Remove the tracked membership.\\n    LibAddressSet.Data storage memberFasts = s.fastMemberships[member];\\n    memberFasts.remove(msg.sender, false);\\n  }\\n}\\n\",\"keccak256\":\"0xcc14c96ccdbc94599a0b5d34e45461c825ee4c28a874cb078edf11018aae0077\",\"license\":\"MIT\"},\"contracts/exchange/lib/AExchangeFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibConstants.sol';\\nimport '../../lib/LibAddressSet.sol';\\nimport '../lib/LibExchange.sol';\\nimport '../../interfaces/IERC173.sol';\\nimport '../../interfaces/IHasMembers.sol';\\n\\n\\n/**\\n* @dev This contract is a group of modifiers that can be used by any Exchange facets to guard against\\n*       certain permissions.\\n*/\\nabstract contract AExchangeFacet {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  // Modifiers.\\n\\n  /// @dev Ensures that a method can only be called by another facet of the same diamond.\\n  modifier diamondInternal() {\\n    require(msg.sender == address(this), LibConstants.INTERNAL_METHOD);\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the owner of this diamond.\\n  modifier diamondOwner() {\\n    require(msg.sender == IERC173(address(this)).owner(), LibConstants.REQUIRES_DIAMOND_OWNERSHIP);\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the singleton deployer contract factory.\\n  modifier deployerContract() {\\n    require(msg.sender == LibConstants.DEPLOYER_CONTRACT, LibConstants.INTERNAL_METHOD);\\n    _;\\n  }\\n\\n  /** @dev Requires that the given address is a member of the linked SPC.\\n   *  @param candidate is the address to be checked.\\n   */\\n  modifier spcMembership(address candidate) {\\n    require(IHasMembers(LibExchange.data().spc).isMember(candidate), LibConstants.REQUIRES_SPC_MEMBERSHIP);\\n    _;\\n  }\\n\\n  /** @dev Requires that the given address is a member of the exchange.\\n   *  @param candidate is the address to be checked.\\n   */\\n  modifier membership(address candidate) {\\n    require(LibExchange.data().memberSet.contains(candidate), LibConstants.REQUIRES_FAST_MEMBERSHIP);\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x80a065d5ae056ce96159b02adac4fb5f877169f2a9fbaa05434e4644bdc5cef0\",\"license\":\"MIT\"},\"contracts/exchange/lib/LibExchange.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\n\\nlibrary LibExchange {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Exchange.storage'):\\n  bytes32 internal constant STORAGE_SLOT = 0x58cca9481e011ced58c1d520ef5aad456e5805265d66de8df7c52f680c417394;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev The internal pointer to the SPC contract.\\n    address spc;\\n    /// @dev This is where we hold our members data.\\n    LibAddressSet.Data memberSet;\\n    /// @dev This is where we keep track of our member FAST memberships.\\n    mapping(address => LibAddressSet.Data) fastMemberships;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0xbaff538549fe11007601a828a4359fbfdcf84253e5bf424e96eb0e55014de80a\",\"license\":\"MIT\"},\"contracts/fast/FastAccessFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../interfaces/IHasMembers.sol';\\nimport '../interfaces/IHasGovernors.sol';\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport '../exchange/ExchangeTopFacet.sol';\\nimport './FastTokenFacet.sol';\\nimport './lib/AFastFacet.sol';\\nimport './lib/LibFast.sol';\\nimport './lib/LibFastAccess.sol';\\nimport './FastTopFacet.sol';\\n\\n\\n/**\\n* @dev The FAST Access Smart Contract is the source of truth when it comes to\\n* permissioning and ACLs within a given FAST network.\\n*/\\ncontract FastAccessFacet is AFastFacet, IHasMembers, IHasGovernors {\\n  using LibAddressSet for LibAddressSet.Data;\\n  /// Structs.\\n\\n  /**\\n   * @dev This structure isn't used anywhere in storage. Instead, it\\n   * allows various methods of the contract to return all the flags\\n   * associated with a given address in one go.\\n   */\\n  struct Flags {\\n    bool isGovernor;\\n    bool isMember;\\n  }\\n\\n  /// Constants.\\n\\n  // This represents how much Eth we provision new governors with.\\n  uint256 constant private GOVERNOR_ETH_PROVISION = 10 ether;\\n  // This represents how much Eth we provision new members with.\\n  uint256 constant private MEMBER_ETH_PROVISION = 1 ether;\\n\\n  /// Governorship related stuff.\\n\\n  /**\\n   * @dev Queries whether a given address is a governor or not.\\n   */\\n  function isGovernor(address candidate)\\n      external view override returns(bool) {\\n    return LibFastAccess.data().governorSet.contains(candidate);\\n  }\\n\\n  /**\\n   * @dev Queries the number of governors in the governorship list.\\n   */\\n  function governorCount()\\n      external override view returns(uint256) {\\n    return LibFastAccess.data().governorSet.values.length;\\n  }\\n\\n  /**\\n   * @dev Returns a page of governors.\\n   */\\n  function paginateGovernors(uint256 index, uint256 perPage)\\n      external override view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibFastAccess.\\n      data().governorSet.values,\\n      index,\\n      perPage\\n    );\\n  }\\n\\n  /**\\n   * @dev Adds a governor to the governorship list.\\n   */\\n  function addGovernor(address payable governor)\\n      external override\\n      spcMembership(msg.sender) {\\n    // Add governor to list.\\n    LibFastAccess.data().governorSet.add(governor, false);\\n    // If the address is a regular wallet...\\n    if (!LibHelpers.isContract(governor)) {\\n      // Provision the new governor with Eth if possible.\\n      FastTopFacet(payable(address(this))).payUpTo(governor, GOVERNOR_ETH_PROVISION);\\n    }\\n    // Emit!\\n    emit LibFastAccess.GovernorAdded(governor);\\n  }\\n\\n  /**\\n   * @dev Removes a governor from the governorship list.\\n   */\\n  function removeGovernor(address governor)\\n      external override\\n      spcMembership(msg.sender) {\\n    // Remove governor.\\n    LibFastAccess.data().governorSet.remove(governor, false);\\n    // Emit!\\n    emit LibFastAccess.GovernorRemoved(governor);\\n  }\\n\\n  /// Membership related stuff.\\n\\n  /**\\n   * @dev Queries whether a given address is a member or not.\\n   */\\n  function isMember(address candidate)\\n      external override view returns(bool) {\\n    return LibFastAccess.data().memberSet.contains(candidate);\\n  }\\n\\n  /**\\n   * @dev Queries the number of members in the membership list.\\n   */\\n  function memberCount()\\n      external override view returns(uint256) {\\n    return LibFastAccess.data().memberSet.values.length;\\n  }\\n\\n  /**\\n   * @dev Returns a page of members.\\n   */\\n  function paginateMembers(uint256 index, uint256 perPage)\\n      external override view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(\\n      LibFastAccess.data().memberSet.values,\\n      index,\\n      perPage\\n    );\\n  }\\n\\n  /**\\n   * @dev Adds a member to the membership list.\\n   */\\n  function addMember(address payable member)\\n      external override \\n      governance(msg.sender) exchangeMember(member) {\\n    // Add the member.\\n    LibFastAccess.data().memberSet.add(member, false);\\n    // If the address is a regular wallet...\\n    if (!LibHelpers.isContract(member)) {\\n      // Provision the new member with Eth if possible.\\n      FastTopFacet(payable(address(this))).payUpTo(member, MEMBER_ETH_PROVISION);\\n    }\\n    // Notify exchange that this member was added to this FAST.\\n    ExchangeTopFacet(LibFast.data().exchange).memberAddedToFast(member);\\n    // Emit!\\n    emit IHasMembers.MemberAdded(member);\\n  }\\n\\n  /**\\n   * @dev Removes a member from the membership list.\\n   */\\n  function removeMember(address member)\\n      external override \\n      governance(msg.sender) {\\n    // Notify token contract.\\n    FastTokenFacet(address(this)).beforeRemovingMember(member);\\n    // Remove member.\\n    LibFastAccess.data().memberSet.remove(member, false);\\n    // Notify exchange that this member was removed from this FAST.\\n    ExchangeTopFacet(LibFast.data().exchange).memberRemovedFromFast(member);\\n    // Emit!\\n    emit IHasMembers.MemberRemoved(member);\\n  }\\n\\n  /// Flags.\\n\\n  /**\\n   * @dev Retrieves flags for a given address.\\n   */\\n  function flags(address a)\\n      external view returns(Flags memory) {\\n    LibFastAccess.Data storage s = LibFastAccess.data();\\n    return\\n      Flags({\\n        isGovernor: s.governorSet.contains(a),\\n        isMember: s.memberSet.contains(a)\\n      });\\n  }\\n}\\n\",\"keccak256\":\"0x952195d7a1d8fac0f5647d1e43fb0de9ee3e1674e6d5247fb2633c5506161388\",\"license\":\"MIT\"},\"contracts/fast/FastHistoryFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibPaginate.sol';\\nimport './lib/AFastFacet.sol';\\nimport './lib/LibFastHistory.sol';\\n\\n\\ncontract FastHistoryFacet is AFastFacet {\\n  /// Minting history-keeping methods.\\n\\n  function minted(uint256 amount, string calldata ref)\\n      external diamondInternal() {\\n    // Keep track of the mint.\\n    LibFastHistory.data().supplyProofs.push(\\n      LibFastHistory.SupplyProof({\\n        op: LibFastHistory.SupplyOp.Mint,\\n        amount: amount,\\n        blockNumber: block.number,\\n        ref: ref\\n      })\\n    );\\n  }\\n\\n  function burnt(uint256 amount, string calldata ref)\\n      external diamondInternal() {\\n    // Keep track of the unmint.\\n    LibFastHistory.data().supplyProofs.push(\\n      LibFastHistory.SupplyProof({\\n        op: LibFastHistory.SupplyOp.Burn,\\n        amount: amount,\\n        blockNumber: block.number,\\n        ref: ref\\n      })\\n    );\\n  }\\n\\n  function supplyProofCount()\\n      external view returns(uint256) {\\n    return LibFastHistory.data().supplyProofs.length;\\n  }\\n\\n  function paginateSupplyProofs(uint256 cursor, uint256 perPage)\\n      external view returns(LibFastHistory.SupplyProof[] memory, uint256) {\\n    return LibPaginate.supplyProofs(LibFastHistory.data().supplyProofs, cursor, perPage);\\n  }\\n\\n  /// Transfer history-keeping methods.\\n\\n  function transfered(address spender, address from, address to, uint256 amount, string calldata ref)\\n      external diamondInternal() {\\n    LibFastHistory.Data storage s = LibFastHistory.data();\\n    // Keep track of the transfer proof ID for the sender and for the recipient.\\n    s.transferProofInvolvements[from].push(s.transferProofs.length);\\n    s.transferProofInvolvements[to].push(s.transferProofs.length);\\n    // Keep track of the transfer proof globally.\\n    s.transferProofs.push(\\n      LibFastHistory.TransferProof({\\n        spender: spender,\\n        from: from,\\n        to: to,\\n        amount: amount,\\n        blockNumber: block.number,\\n        ref: ref\\n      })\\n    );\\n  }\\n\\n  function transferProofCount()\\n      external view returns(uint256) {\\n    return LibFastHistory.data().transferProofs.length;\\n  }\\n\\n  function paginateTransferProofs(uint256 cursor, uint256 perPage)\\n      external view returns(LibFastHistory.TransferProof[] memory, uint256) {\\n    return LibPaginate.transferProofs(LibFastHistory.data().transferProofs, cursor, perPage);\\n  }\\n\\n  function transferProofByInvolveeCount(address involvee)\\n      external view returns(uint256) {\\n    return LibFastHistory.data().transferProofInvolvements[involvee].length;\\n  }\\n\\n  function paginateTransferProofIndicesByInvolvee(address involvee, uint256 cursor, uint256 perPage)\\n      external view returns(uint256[] memory, uint256) {\\n    return LibPaginate.uint256s(LibFastHistory.data().transferProofInvolvements[involvee], cursor, perPage);\\n  }\\n\\n  function paginateTransferProofsByInvolvee(address involvee, uint256 cursor, uint256 perPage)\\n      external view returns(LibFastHistory.TransferProof[] memory, uint256) {\\n    LibFastHistory.Data storage s = LibFastHistory.data();\\n    uint256[] storage collection  = s.transferProofInvolvements[involvee];\\n    uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n    LibFastHistory.TransferProof[] memory values = new LibFastHistory.TransferProof[](length);\\n    for (uint256 i = 0; i < length; i++) {\\n      values[i] = s.transferProofs[collection[cursor + i]];\\n    }\\n    return (values, cursor + length);\\n  }\\n}\\n\",\"keccak256\":\"0x5596e26868dce38659495b3acddbaec7045698d0ecc9039f1170c5a9f1e21cb1\",\"license\":\"MIT\"},\"contracts/fast/FastInitFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../interfaces/IERC20.sol';        // Token.\\nimport '../interfaces/IERC165.sol';       // Interface Support.\\nimport '../interfaces/IERC173.sol';       // Ownership.\\nimport '../interfaces/IERC1404.sol';      // Transfer Restriction.\\nimport '../interfaces/IDiamondCut.sol';   // Facet management.\\nimport '../interfaces/IDiamondLoupe.sol'; // Facet introspection.\\nimport '../interfaces/IHasGovernors.sol'; // Governorship management.\\nimport '../interfaces/IHasMembers.sol';   // Membership management.\\nimport '../lib/LibDiamond.sol';\\nimport '../lib/LibAddressSet.sol';\\nimport '../exchange/ExchangeTopFacet.sol';\\nimport './lib/AFastFacet.sol';\\n\\n/**\\n* @dev Note that although this contract doesn't explicitelly inherit from IERC173, ERC165, IDiamondLoupe etc, all\\n*       methods are in fact implemented by the underlaying Diamond proxy. It is therefore safe to\\n*       perform casts directly on the current contract address into these interfaces.\\n*/ \\ncontract FastInitFacet is AFastFacet {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  // Initializers.\\n\\n  struct InitializerParams {\\n    // Top-level stuff.\\n    address spc;\\n    address exchange;\\n    // Access stuff.\\n    address governor;\\n    // Token stuff.\\n    string name;\\n    string symbol;\\n    uint256 decimals;\\n    bool hasFixedSupply;\\n    bool isSemiPublic;\\n  }\\n\\n  function initialize(InitializerParams calldata params)\\n      external\\n      deployerContract() {\\n    // Grab our top-level storage.\\n    LibFast.Data storage fastData = LibFast.data();\\n    // Make sure we havn't initialized yet.\\n    require(fastData.version < LibFast.STORAGE_VERSION, 'Already initialized');\\n    fastData.version = LibFast.STORAGE_VERSION;\\n\\n    // Register interfaces.\\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n    ds.supportedInterfaces[type(IERC20).interfaceId] = true;\\n    ds.supportedInterfaces[type(IERC165).interfaceId] = true;\\n    ds.supportedInterfaces[type(IERC173).interfaceId] = true;\\n    ds.supportedInterfaces[type(IERC1404).interfaceId] = true;\\n    ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\\n    ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\\n    ds.supportedInterfaces[type(IHasGovernors).interfaceId] = true;\\n    ds.supportedInterfaces[type(IHasMembers).interfaceId] = true;\\n\\n    // ------------------------------------- //\\n\\n    // Initialize top-level storage.\\n    fastData.spc = params.spc;\\n    fastData.exchange = params.exchange;\\n    \\n    // ------------------------------------- //\\n\\n    // Initialize access storage.\\n    LibFastAccess.Data storage accessData = LibFastAccess.data();\\n    accessData.version = LibFastAccess.STORAGE_VERSION;\\n    // Add the governor both as a governor and as a member.\\n    accessData.memberSet.add(params.governor, false);\\n    accessData.governorSet.add(params.governor, false);\\n    // Emit!\\n    emit LibFastAccess.GovernorAdded(params.governor);\\n    emit LibFastAccess.MemberAdded(params.governor);\\n\\n    // ------------------------------------- //\\n\\n    // Initialize token storage.\\n    LibFastToken.Data storage tokenData = LibFastToken.data();\\n    tokenData.version = LibFastToken.STORAGE_VERSION;\\n    // Set up ERC20 related stuff.\\n    (tokenData.name, tokenData.symbol, tokenData.decimals) =\\n      (params.name,   params.symbol,   params.decimals);\\n    tokenData.totalSupply = 0;\\n    // Initialize other internal stuff.\\n    (tokenData.hasFixedSupply, tokenData.isSemiPublic) =\\n      (params.hasFixedSupply,   params.isSemiPublic);\\n    tokenData.transferCredits = 0;\\n  }\\n}\\n\",\"keccak256\":\"0x0dbef77346567fe054bf197e21a17ad2d17cd7d41d2c581ca688a831b0f1680d\",\"license\":\"MIT\"},\"contracts/fast/FastTokenFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../interfaces/IERC20.sol';\\nimport '../interfaces/IERC1404.sol';\\nimport '../lib/LibDiamond.sol';\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport './FastAccessFacet.sol';\\nimport './FastHistoryFacet.sol';\\nimport './lib/AFastFacet.sol';\\n\\n\\ncontract FastTokenFacet is AFastFacet, IERC20, IERC1404 {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  /// Constants.\\n\\n  // Restriction codes.\\n  uint8 private constant INSUFFICIENT_TRANSFER_CREDITS_CODE = 1;\\n  uint8 private constant REQUIRES_FAST_MEMBERSHIP_CODE = 2;\\n  uint8 private constant REQUIRES_EXCHANGE_MEMBERSHIP_CODE = 3;\\n  uint8 private constant REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT_CODE = 4;\\n\\n  // Events.\\n\\n  event Minted(uint256 indexed amount, string indexed ref);\\n  event Burnt(uint256 indexed amount, string indexed ref);\\n\\n  event TransferCreditsAdded(address indexed spcMember, uint256 amount);\\n  event TransferCreditsDrained(address indexed spcMember, uint256 amount);\\n\\n  event Disapproval(address indexed owner, address indexed spender);\\n\\n  // Public functions.\\n\\n  function isSemiPublic()\\n      external view returns(bool) {\\n    return LibFastToken.data().isSemiPublic;\\n  }\\n\\n  function setIsSemiPublic(bool flag)\\n      external\\n      spcMembership(msg.sender) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    // Someone is trying to toggle back to private?... No can do!isSemiPublic\\n    require(!s.isSemiPublic || s.isSemiPublic == flag, LibConstants.UNSUPPORTED_OPERATION);\\n    s.isSemiPublic = flag;\\n  }\\n\\n  function hasFixedSupply()\\n      external view returns(bool) {\\n    return LibFastToken.data().hasFixedSupply;\\n  }\\n\\n  function setHasFixedSupply(bool flag)\\n      external\\n      spcMembership(msg.sender) {\\n    LibFastToken.data().hasFixedSupply = flag;\\n  }\\n\\n  /// Minting methods.\\n\\n  function mint(uint256 amount, string calldata ref)\\n      external\\n      spcMembership(msg.sender) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    // We want to make sure that either of these two is true:\\n    // - The token doesn't have fixed supply.\\n    // - The token has fixed supply but has no tokens yet (First and only mint).\\n    require(\\n      !s.hasFixedSupply || (s.totalSupply == 0 && balanceOf(address(0)) == 0),\\n      LibConstants.REQUIRES_CONTINUOUS_SUPPLY\\n    );\\n\\n    // Prepare the minted amount on the zero address.\\n    s.balances[address(0)] += amount;\\n\\n    // Keep track of the minting operation.\\n    FastHistoryFacet(address(this)).minted(amount, ref);\\n\\n    // Emit!\\n    emit Minted(amount, ref);\\n  }\\n\\n  function burn(uint256 amount, string calldata ref)\\n      external\\n      spcMembership(msg.sender) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    require(!s.hasFixedSupply, LibConstants.REQUIRES_CONTINUOUS_SUPPLY);\\n    require(balanceOf(address(0)) >= amount, LibConstants.INSUFFICIENT_FUNDS);\\n\\n    // Remove the minted amount from the zero address.\\n    s.balances[address(0)] -= amount;\\n\\n    // Keep track of the minting operation.\\n    FastHistoryFacet(address(this)).burnt(amount, ref);\\n\\n    // Emit!\\n    emit Burnt(amount, ref);\\n  }\\n\\n  /// Tranfer Credit management.\\n\\n  function transferCredits()\\n      external view returns(uint256) {\\n    return LibFastToken.data().transferCredits;\\n  }\\n\\n  function addTransferCredits(uint256 amount)\\n      external\\n      spcMembership(msg.sender) {\\n    LibFastToken.data().transferCredits += amount;\\n    emit TransferCreditsAdded(msg.sender, amount);\\n  }\\n\\n  function drainTransferCredits()\\n      external\\n      spcMembership(msg.sender) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    emit TransferCreditsDrained(msg.sender, s.transferCredits);\\n    s.transferCredits = 0;\\n  }\\n\\n  /// ERC20 implementation and transfer related methods.\\n\\n  function name()\\n      external view returns(string memory) {\\n    return LibFastToken.data().name;\\n  }\\n\\n  function symbol()\\n      external view returns(string memory) {\\n    return LibFastToken.data().symbol;\\n  }\\n\\n  function decimals()\\n      external view returns(uint256) {\\n    return LibFastToken.data().decimals;\\n  }\\n\\n  function totalSupply()\\n      external override view returns(uint256) {\\n    return LibFastToken.data().totalSupply;\\n  }\\n\\n  function balanceOf(address owner)\\n      public view override returns(uint256) {\\n    return LibFastToken.data().balances[owner];\\n  }\\n\\n  function transfer(address to, uint256 amount)\\n      external override returns(bool) {\\n    _transfer(msg.sender, msg.sender, to, amount, 'Unspecified - via ERC20');\\n    return true;\\n  }\\n\\n  function transferWithRef(address to, uint256 amount, string memory ref)\\n      external {\\n    return _transfer(msg.sender, msg.sender, to, amount, ref);\\n  }\\n\\n  function allowance(address owner, address spender)\\n      public view override returns(uint256) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    // If the allowance being queried is from the zero address and the spender\\n    // is a governor, we want to make sure that the spender has full rights over it.\\n    if (owner == address(0) && FastAccessFacet(address(this)).isGovernor(spender)) {\\n      return s.balances[address(0)];\\n   } else {\\n      return s.allowances[owner][spender];\\n    }\\n  }\\n\\n  function approve(address spender, uint256 amount)\\n      external override\\n      membership(msg.sender)\\n      returns(bool) {\\n    _approve(msg.sender, spender, amount);\\n    return true;\\n  }\\n\\n  function disapprove(address spender)\\n      external\\n      membership(msg.sender) {\\n    _disapprove(msg.sender, spender);\\n  }\\n\\n  function transferFrom(address from, address to, uint256 amount)\\n      external override returns(bool) {\\n    transferFromWithRef(from, to, amount, 'Unspecified - via ERC20');\\n    return true;\\n  }\\n\\n  function transferFromWithRef(address from, address to, uint256 amount, string memory ref)\\n      public {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    // If the funds are coming from the zero address, we must be a governor.\\n    if (from == address(0)) {\\n      require(FastAccessFacet(address(this)).isGovernor(msg.sender), LibConstants.REQUIRES_FAST_GOVERNORSHIP);\\n    } else {\\n      require(allowance(from, msg.sender) >= amount, LibConstants.INSUFFICIENT_ALLOWANCE);\\n\\n      // Only decrease allowances if the sender of the funds isn't the zero address.\\n      uint256 newAllowance = s.allowances[from][msg.sender] -= amount;\\n      // If the allowance reached zero, we want to remove that allowance from\\n      // the various other places where we keep track of them.\\n      if (newAllowance == 0) {\\n        s.allowancesByOwner[from].remove(msg.sender, true);\\n        s.allowancesBySpender[msg.sender].remove(from, true);\\n      }\\n    }\\n\\n    _transfer(msg.sender, from, to, amount, ref);\\n  }\\n\\n  /// Allowances query operations.\\n\\n  function givenAllowanceCount(address owner)\\n      external view returns(uint256) {\\n    return LibFastToken.data().allowancesByOwner[owner].values.length;\\n  }\\n\\n  function paginateAllowancesByOwner(address owner, uint256 index, uint256 perPage)\\n      external view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(\\n      LibFastToken.data().allowancesByOwner[owner].values,\\n      index,\\n      perPage\\n    );\\n  }\\n\\n  function receivedAllowanceCount(address spender)\\n      external view returns(uint256) {\\n    return LibFastToken.data().allowancesBySpender[spender].values.length;\\n  }\\n\\n  function paginateAllowancesBySpender(address spender, uint256 index, uint256 perPage)\\n      external view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(\\n      LibFastToken.data().allowancesBySpender[spender].values,\\n      index,\\n      perPage\\n    );\\n  }\\n\\n  /// ERC1404 implementation.\\n\\n  function detectTransferRestriction(address from, address to, uint256 amount)\\n      external view override returns(uint8) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    if (s.transferCredits < amount) {\\n      return INSUFFICIENT_TRANSFER_CREDITS_CODE;\\n    } else if (!FastAccessFacet(address(this)).isMember(from) ||\\n               !FastAccessFacet(address(this)).isMember(to)) {\\n      return s.isSemiPublic\\n        ? REQUIRES_EXCHANGE_MEMBERSHIP_CODE\\n        : REQUIRES_FAST_MEMBERSHIP_CODE;\\n    } else if (from == to) {\\n      return REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT_CODE;\\n    }\\n    return 0;\\n  }\\n\\n  function messageForTransferRestriction(uint8 restrictionCode)\\n      external override pure returns(string memory) {\\n    if (restrictionCode == INSUFFICIENT_TRANSFER_CREDITS_CODE) {\\n      return LibConstants.INSUFFICIENT_TRANSFER_CREDITS;\\n    } else if (restrictionCode == REQUIRES_EXCHANGE_MEMBERSHIP_CODE) {\\n      return LibConstants.REQUIRES_EXCHANGE_MEMBERSHIP;\\n    } else if (restrictionCode == REQUIRES_FAST_MEMBERSHIP_CODE) {\\n      return LibConstants.REQUIRES_FAST_MEMBERSHIP;\\n    } else if (restrictionCode == REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT_CODE) {\\n      return LibConstants.REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT;\\n    }\\n    revert(LibConstants.UNKNOWN_RESTRICTION_CODE);\\n  }\\n\\n  // Private.\\n\\n  function _transfer(address spender, address from, address to, uint256 amount, string memory ref)\\n      private\\n      membershipOrZero(from) membershipOrZero(to) differentAddresses(from, to) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    require(s.balances[from] >= amount, LibConstants.INSUFFICIENT_FUNDS);\\n    require(\\n      from == address(0) ||\\n        s.transferCredits >= amount,\\n      LibConstants.INSUFFICIENT_TRANSFER_CREDITS\\n    );\\n\\n    // Keep track of the balances.\\n    s.balances[from] -= amount;\\n    s.balances[to] += amount;\\n\\n    // If the funds are going to the ZERO address, decrease total supply.\\n    if (to == address(0)) { s.totalSupply -= amount; }\\n    // If the funds are moving from the zero address, increase total supply.\\n    else if (from == address(0)) { s.totalSupply += amount; }\\n\\n    // Keep track of the transfer.\\n    FastHistoryFacet(address(this)).transfered(spender, from, to, amount, ref);\\n\\n    // Emit!\\n    emit IERC20.Transfer(from, to, amount);\\n  }\\n\\n  function _approve(address from, address spender, uint256 amount)\\n      private {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    // Store allowance...\\n    s.allowances[from][spender] += amount;\\n    // Keep track of given and received allowances.\\n    s.allowancesByOwner[from].add(spender, true);\\n    s.allowancesBySpender[spender].add(from, true);\\n\\n    // Emit!\\n    emit IERC20.Approval(from, spender, amount);\\n  }\\n\\n  function _disapprove(address from, address spender)\\n      private {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    // Remove allowance.\\n    s.allowances[from][spender] = 0;\\n    s.allowancesByOwner[from].remove(spender, false);\\n    s.allowancesBySpender[spender].remove(from, false);\\n\\n    // Emit!\\n    emit Disapproval(from, spender);\\n  }\\n\\n  /// Callbacks from other contracts.\\n\\n  // WARNING: This function contains two loops. We know that this should never\\n  // happen in solidity. However:\\n  // - In the context of our private chain, gas is cheap.\\n  // - It can only be called by a governor.\\n  function beforeRemovingMember(address member)\\n      external diamondInternal() {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    // If there are token at member's address, move them back to the zero address.\\n    {\\n      uint256 balance = balanceOf(member);\\n      if (balance > 0) {\\n        _transfer(address(0), member, address(0), balance, 'Member removal');\\n      }\\n    }\\n\\n    // Remove all given allowances.\\n    {\\n      address[] storage gaData = s.allowancesByOwner[member].values;\\n      while (gaData.length > 0) { _disapprove(member, gaData[0]); }\\n    }\\n\\n    // Remove all received allowances.\\n    {\\n      address[] storage raData = s.allowancesBySpender[member].values;\\n      while (raData.length > 0) { _disapprove(raData[0], member); }\\n    }\\n  }\\n\\n  // Modifiers.\\n\\n  modifier differentAddresses(address a, address b) {\\n    require(a != b, LibConstants.REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT);\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x07b3b7965ae0eca80446f0215ca0cb695d7d0989f564f9382e8e9d01390f2222\",\"license\":\"MIT\"},\"contracts/fast/FastTopFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibConstants.sol';\\nimport '../lib/LibHelpers.sol';\\nimport './lib/AFastFacet.sol';\\nimport './lib/LibFast.sol';\\n\\ncontract FastTopFacet is AFastFacet {\\n  // Events.\\n\\n  // Eth provisioning related events.\\n  event EthReceived(address indexed from, uint256 amount);\\n  event EthDrained(address indexed to, uint256 amount);\\n\\n  // Getters.\\n\\n  function spcAddress()\\n      external view returns(address) {\\n    return LibFast.data().spc;\\n  }\\n\\n  function exchangeAddress()\\n      external view returns(address) {\\n    return LibFast.data().exchange;\\n  }\\n\\n  // Provisioning functions.\\n\\n  function provisionWithEth()\\n      external payable {\\n    require(msg.value > 0, LibConstants.MISSING_ATTACHED_ETH);\\n    emit EthReceived(msg.sender, msg.value);\\n  }\\n\\n  function drainEth()\\n      external\\n      spcMembership(msg.sender) {\\n    uint256 amount = payable(address(this)).balance;\\n    payable(msg.sender).transfer(amount);\\n    emit EthDrained(msg.sender, amount);\\n  }\\n\\n  /**\\n  * @dev This function allows contracts of the FAST network to request ETH\\n  * provisioning to arbitrary addresses.\\n  */\\n  function payUpTo(address payable recipient, uint256 amount)\\n      external diamondInternal() {\\n    require(recipient != address(0), LibConstants.REQUIRES_NON_ZERO_ADDRESS);\\n    amount = LibHelpers.upTo(recipient, amount);\\n    // Transfer some eth!\\n    if (amount != 0) { recipient.transfer(amount); }\\n  }\\n}\\n\",\"keccak256\":\"0xc049fba76d7a8d7d937f7816423cac74eb0c79a12a270e95efa33fbe435cace7\",\"license\":\"MIT\"},\"contracts/fast/lib/AFastFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibConstants.sol';\\nimport '../../lib/LibHelpers.sol';\\nimport '../../lib/LibAddressSet.sol';\\nimport '../../interfaces/IHasMembers.sol';\\nimport '../../interfaces/IERC173.sol';\\nimport '../lib/LibFast.sol';\\nimport '../lib/LibFastAccess.sol';\\nimport '../lib/LibFastToken.sol';\\n\\n\\n/**\\n* @dev This contract is a group of modifiers that can be used by any facets to guard against\\n*       certain permissions.\\n*/\\nabstract contract AFastFacet {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  /// Modifiers.\\n\\n  /// @dev Ensures that a method can only be called by another facet of the same diamond.\\n  modifier diamondInternal() {\\n    require(msg.sender == address(this), LibConstants.INTERNAL_METHOD);\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the owner of this diamond.\\n  modifier diamondOwner() {\\n    require(msg.sender == IERC173(address(this)).owner(), LibConstants.REQUIRES_DIAMOND_OWNERSHIP);\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the singleton deployer contract factory.\\n  modifier deployerContract() {\\n    require(msg.sender == LibConstants.DEPLOYER_CONTRACT, LibConstants.INTERNAL_METHOD);\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is **not** a contract.\\n   *  @param a The address to check.\\n   */\\n  modifier nonContract(address a) {\\n    require(!LibHelpers.isContract(a), LibConstants.REQUIRES_NON_CONTRACT_ADDR);\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is a member of the Exchange.\\n   *  @param a The address to check.\\n   */\\n  modifier exchangeMember(address a) {\\n    require(IHasMembers(LibFast.data().exchange).isMember(a), LibConstants.REQUIRES_EXCHANGE_MEMBERSHIP);\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is a member of the SPC.\\n   *  @param a The address to check.\\n   */\\n  modifier spcMembership(address a) {\\n    require(IHasMembers(LibFast.data().spc).isMember(a), LibConstants.REQUIRES_SPC_MEMBERSHIP);\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is a governor of the FAST.\\n   *  @param a The address to check.\\n   */\\n  modifier governance(address a) {\\n    require(LibFastAccess.data().governorSet.contains(a), LibConstants.REQUIRES_FAST_GOVERNORSHIP);\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is a member of the FAST.\\n   *  @param a The address to check.\\n   */\\n  modifier membership(address a) {\\n    require(LibFastAccess.data().memberSet.contains(a), LibConstants.REQUIRES_FAST_MEMBERSHIP);\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is a member of the current FAST or the Zero Address.\\n   *  @param a The address to check.\\n   */\\n  modifier membershipOrZero(address a) {\\n    require(\\n      LibFastAccess.data().memberSet.contains(a) ||\\n      (LibFastToken.data().isSemiPublic && IHasMembers(LibFast.data().exchange).isMember(a)) ||\\n        a == address(0),\\n      LibConstants.REQUIRES_FAST_MEMBERSHIP\\n    );\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x66b70f0d092b9488e84c47d35cd4f259bbfabcd27e212a9d2e1a6fdfc361f6c3\",\"license\":\"MIT\"},\"contracts/fast/lib/LibFast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\nlibrary LibFast {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Fast.storage'):\\n  bytes32 internal constant STORAGE_SLOT = 0x80c187ea6f955fd624c41fb7a18011cc87d98c6f4c06d897b59142f65707e705;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev The internal pointer to the SPC contract.\\n    address spc;\\n    /// @dev The internal pointer to the Exchange contract.\\n    address exchange;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0x8b155db07484240635af56d629dbc7827ed126db9119c16d2d139fb6ad4c1c6f\",\"license\":\"MIT\"},\"contracts/fast/lib/LibFastAccess.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\nlibrary LibFastAccess {\\n  // These are from IHasMembers.\\n  event MemberAdded(address indexed member);\\n  event MemberRemoved(address indexed member);\\n  // These are from IHasGovernors.\\n  event GovernorAdded(address indexed governor);\\n  event GovernorRemoved(address indexed governor);\\n\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Fast.storage.Access'):\\n  bytes32 internal constant STORAGE_SLOT = 0x87ed8063ac9ead3b2eb7551ed3d89b29fcbf44d6733084b5c82e95d5120ece9a;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev We hold the list of the FAST governors in there.\\n    LibAddressSet.Data governorSet;\\n    // @dev The FAST members are held in there.\\n    LibAddressSet.Data memberSet;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0xae5d13b3662db3727c189c24510bab551acb16946873cbaff0d485211a85d5dd\",\"license\":\"MIT\"},\"contracts/fast/lib/LibFastHistory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\nlibrary LibFastHistory {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Fast.storage.History'):\\n  bytes32 internal constant STORAGE_SLOT = 0x6bc8b61a9dd5fc049ea98027492a801d74e35fdf4d80d7fecd551a16e88fdbb4;\\n\\n  // Storage structures.\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev All minting proofs are kept here.\\n    SupplyProof[] supplyProofs;\\n    /// @dev All transfer proofs are kept here.\\n    TransferProof[] transferProofs;\\n    /// @dev All transfers indices involving a given address are kept here.\\n    mapping(address => uint256[]) transferProofInvolvements;\\n  }\\n\\n  // Other structures.\\n\\n  /// @dev A minting operation could either be to mint or unmint tokens.\\n  enum SupplyOp { Mint, Burn }\\n\\n  /// @dev Minting operations are recorded for papertrail. This is the structure that keeps track of them.\\n  struct SupplyProof {\\n    SupplyOp op;\\n    uint256 amount;\\n    uint256 blockNumber;\\n    string ref;\\n  }\\n\\n  /// @dev Every transfer in is recorded. This is the structure that keeps track of them.\\n  struct TransferProof {\\n    address spender;\\n    address from;\\n    address to;\\n    uint256 amount;\\n    uint256 blockNumber;\\n    string ref;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0xd6af0fc0867dd0259fa6e0797f2b46cffac8a36f0380bf266e3ccf778aeb724c\",\"license\":\"MIT\"},\"contracts/fast/lib/LibFastToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\n\\nlibrary LibFastToken {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Fast.storage.Token'):\\n  bytes32 internal constant STORAGE_SLOT = 0xb098747b87c5c0e2a32eb9b06725e9bad4263809bcda628ceadc1a686bcb8261;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    // ERC20 related properties for this FAST Token.\\n    string name;\\n    string symbol;\\n    uint256 decimals;\\n    uint256 totalSupply;\\n    // Every time a transfer is executed, the credit decreases by the amount\\n    // of said transfer.\\n    // It becomes impossible to transact once it reaches zero, and must\\n    // be provisioned by an SPC governor.\\n    uint256 transferCredits;\\n    // Whether or not external people can hold and transfer tokens on this FAST.\\n    bool isSemiPublic;\\n    // We have to track whether this token has continuous minting or fixed supply.\\n    bool hasFixedSupply;\\n    // Our members balances are held here.\\n    mapping(address => uint256) balances;\\n    // Allowances are stored here.\\n    mapping(address => mapping(address => uint256)) allowances;\\n    mapping(address => LibAddressSet.Data) allowancesByOwner;\\n    mapping(address => LibAddressSet.Data) allowancesBySpender;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0xb75ff5b945e308f7297c365aefadaf382ff31ab7ab5a03eb4dd7a8ec4065cc3e\",\"license\":\"MIT\"},\"contracts/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0x7aca95eacea757ff86be09ed6f309fde42e402530ac7beae002e3c2586439a01\",\"license\":\"MIT\"},\"contracts/interfaces/IDiamondLoupe.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupe {\\n    /// These functions are expected to be called frequently\\n    /// by tools.\\n\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\n}\\n\",\"keccak256\":\"0x10884024af2c0f7deca0fac4ddf84e76da5dba35b6e02fabeac8ea54c1a5c6f7\",\"license\":\"MIT\"},\"contracts/interfaces/IERC1404.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\n/**\\n * @dev Interface of the ERC1404 standard as defined in the EIP.\\n */\\ninterface IERC1404 {\\n  /**\\n   * @dev Returns a transfer restriction error code if the transfer shoudln't be permitted,\\n   *      or otherwise returns zero if everything looks fine.\\n   * @param owner is the account from which the tokens should be transfered.\\n   * @param recipient is the target of the transfer.\\n   * @param amount is the amount to be transfered.\\n   * @return a uint8 error code if a problem was detected, otherwise zero.\\n   */\\n  function detectTransferRestriction(address owner, address recipient, uint256 amount)\\n    external\\n    view\\n    returns (uint8);\\n\\n  /**\\n   * @dev Maps a transfer restriction error code into a human-readable string.\\n   * @param code is the code that should be transformed into a string.\\n   * @return A string that describes the given error code.\\n   */\\n  function messageForTransferRestriction(uint8 code) external pure returns (string memory);\\n}\\n\",\"keccak256\":\"0x9ecaada095d66283dda203f77cdd17d18f82bdf58d6fbe7830fc87aed2a80c38\",\"license\":\"MIT\"},\"contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xb736f4923109f238e3bf2d8c71b636a24ca4d56c1206e003348584e4aa4ed263\",\"license\":\"MIT\"},\"contracts/interfaces/IERC173.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @title ERC-173 Contract Ownership Standard\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\n/* is ERC165 */\\ninterface IERC173 {\\n    /// @dev This emits when ownership of a contract changes.\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Get the address of the owner\\n    /// @return owner_ The address of the owner.\\n    function owner() external view returns (address owner_);\\n\\n    /// @notice Set the address of the new owner of the contract\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\n    /// @param _newOwner The address of the new owner of the contract\\n    function transferOwnership(address _newOwner) external;\\n}\\n\",\"keccak256\":\"0x6ab22e74708905d9c31867461fffbd2e24bc6ad094aa1aab39211d99e296ab32\",\"license\":\"MIT\"},\"contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x506634b62ab640b6cfbc4f1299f93a6475b250ec29072c71ca92907c4f747dce\",\"license\":\"MIT\"},\"contracts/interfaces/IHasGovernors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\ninterface IHasGovernors {\\n  event GovernorAdded(address indexed governor);\\n  event GovernorRemoved(address indexed governor);\\n\\n  function isGovernor(address a) external view returns(bool);\\n  function governorCount() external view returns(uint256);\\n  function paginateGovernors(uint256 index, uint256 perPage) external view returns(address[] memory, uint256);\\n  function addGovernor(address payable a) external;\\n  function removeGovernor(address a) external;\\n}\\n\",\"keccak256\":\"0x35836b162c19951d87848f098fab3f42b79a0b9f593640e8ad8f2f2fa5b74d25\",\"license\":\"MIT\"},\"contracts/interfaces/IHasMembers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\ninterface IHasMembers {\\n  event MemberAdded(address indexed member);\\n  event MemberRemoved(address indexed member);\\n\\n  function isMember(address a) external view returns(bool);\\n  function memberCount() external view returns(uint256);\\n  function paginateMembers(uint256 index, uint256 perPage) external view returns(address[] memory, uint256);\\n  function addMember(address payable a) external;\\n  function removeMember(address a) external;\\n}\\n\",\"keccak256\":\"0xab0d7cfb46a5a70bd13783d959df2e8f593269472994ea828273fa563a4c0c39\",\"license\":\"MIT\"},\"contracts/lib/LibAddressSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\nlibrary LibAddressSet {\\n  /// @dev Represents a list of addresses.\\n  struct Data {\\n    mapping(address => uint256) indices;\\n    address[] values;\\n  }\\n\\n  /**\\n   * @dev Adds an item into the storage set. If the address already exists in the\\n   *      set, the function reverts.\\n   * @param d is the internal data storage to use.\\n   * @param key is the address to be added.\\n   */\\n  function add(Data storage d, address key, bool noThrow)\\n      internal {\\n    bool exists = contains(d, key);\\n    if (noThrow && exists) { return; }\\n    require(!exists, 'Address already in set');\\n    d.indices[key] = d.values.length;\\n    d.values.push(key);\\n  }\\n\\n  /**\\n   * @dev Removes an item from the storage set. If the address does not exist in the\\n   *      set, the function reverts.\\n   * @param d is the internal data storage to use.\\n   * @param key is the address to be removed.\\n   */\\n  function remove(Data storage d, address key, bool noThrow)\\n      internal {\\n    bool exists = contains(d, key);\\n    if (noThrow && !exists) { return; }\\n    require(exists, 'Address does not exist in set');\\n    uint256 lastIndex = d.values.length - 1;\\n    address keyToMove = d.values[lastIndex];\\n    uint256 idxToReplace = d.indices[key];\\n    d.indices[keyToMove] = idxToReplace;\\n    d.values[idxToReplace] = keyToMove;\\n    delete d.indices[key];\\n    d.values.pop();\\n  }\\n\\n  /**\\n   * @dev Tests whether or not a given item already exists in the set.\\n   * @param d is the internal data storage to use.\\n   * @param key is the address to test.\\n   * @return a boolean.\\n   */\\n  function contains(Data storage d, address key)\\n      internal view returns(bool) {\\n    return d.values.length == 0\\n      ? false\\n      : d.values[d.indices[key]] == key;\\n  }\\n}\\n\",\"keccak256\":\"0x7daf050d0864e085c227521b1157b4ea652fe75ea7e10f685027b42d6e1caf87\",\"license\":\"MIT\"},\"contracts/lib/LibConstants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\nlibrary LibConstants {\\n  address internal constant ZERO_ADDRESS = address(0);\\n  address internal constant DEPLOYER_CONTRACT = 0x6DF2D25d8C6FD680730ee658b530A05a99BB769a;\\n\\n  string internal constant INTERNAL_METHOD = 'Internal method';\\n  string internal constant REQUIRES_DIAMOND_OWNERSHIP = 'Requires diamond ownership';\\n  string internal constant REQUIRES_FAST_CONTRACT_CALLER = 'Caller must be a FAST contract';\\n  string internal constant REQUIRES_NO_FAST_MEMBERSHIPS = 'Member still part of at least one FAST';\\n\\n  string internal constant REQUIRES_SPC_MEMBERSHIP = 'Requires SPC membership';\\n  string internal constant REQUIRES_EXCHANGE_MEMBERSHIP = 'Requires Exchange membership';\\n  string internal constant REQUIRES_FAST_GOVERNORSHIP = 'Requires FAST governorship';\\n  string internal constant REQUIRES_FAST_MEMBERSHIP = 'Requires FAST membership';\\n\\n  string internal constant DUPLICATE_ENTRY = 'Duplicate entry';\\n  string internal constant UNSUPPORTED_OPERATION = 'Unsupported operation';\\n  string internal constant REQUIRES_NON_ZERO_ADDRESS = 'Requires non-zero address';\\n  string internal constant REQUIRES_NON_CONTRACT_ADDR = 'Address cannot be a contract';\\n\\n  string internal constant MISSING_ATTACHED_ETH = 'Missing attached ETH';\\n  string internal constant REQUIRES_CONTINUOUS_SUPPLY = 'Requires continuous supply';\\n  string internal constant INSUFFICIENT_FUNDS = 'Insufficient token balance';\\n  string internal constant INSUFFICIENT_ALLOWANCE = 'Insufficient allowance';\\n  string internal constant INSUFFICIENT_TRANSFER_CREDITS = 'Insufficient transfer credits';\\n  string internal constant REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT = 'Requires different sender and recipient';\\n  string internal constant UNKNOWN_RESTRICTION_CODE = 'Unknown restriction code';\\n}\\n\",\"keccak256\":\"0x07122b717a522632f20b4bb1d397428df14a12511eea4893ae16a77ecb6d011f\",\"license\":\"MIT\"},\"contracts/lib/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);            \\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }    \\n\\n\\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n        // an immutable function is a function defined directly in a diamond\\n        require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x1c1bcc2f4ce958b3569ec95530879a584e4cf837d585a5059b3b612ad4a71a47\",\"license\":\"MIT\"},\"contracts/lib/LibHelpers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nlibrary LibHelpers {\\n  function upTo(address payable to, uint256 amount)\\n      internal view returns(uint256) {\\n    // If the recipient has more than what is ought to be paid, return.\\n    uint256 toBalance = to.balance;\\n    if (toBalance >= amount) { return 0; }\\n    // If the recipient has some Eth we should only pay the top-up.\\n    amount = amount - toBalance;\\n    // If the available eth is less than what we should pay, just cap it.\\n    uint256 available = payable(address(this)).balance;\\n    if (available < amount) { amount = available; }\\n    // Provision the new fast with Eth.\\n    return amount;\\n  }\\n\\n  function isContract(address target)\\n      internal view returns (bool) {\\n    uint32 size;\\n    assembly { size := extcodesize(target) }\\n    return (size > 0);\\n  }\\n}\\n\",\"keccak256\":\"0xa3ac21d8e6e5f25d9125d2975e7157e5c660bd481fb102c39a64810955d6eaab\",\"license\":\"MIT\"},\"contracts/lib/LibPaginate.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../fast/lib/LibFastHistory.sol';\\n\\n\\nlibrary LibPaginate {\\n  function addresses(address[] storage collection, uint256 cursor, uint256 perPage)\\n    internal view returns(address[] memory, uint256) {\\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n      address[] memory values = new address[](length);\\n      for (uint256 i = 0; i < length; i++) {\\n        values[i] = collection[cursor + i];\\n      }\\n      return (values, cursor + length);\\n  }\\n\\n  function uint256s(uint256[] storage collection, uint256 cursor, uint256 perPage)\\n    internal view returns(uint256[] memory, uint256) {\\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n      uint256[] memory values = new uint256[](length);\\n      for (uint256 i = 0; i < length; i++) {\\n        values[i] = collection[cursor + i];\\n      }\\n      return (values, cursor + length);\\n  }\\n\\n  function supplyProofs(LibFastHistory.SupplyProof[] storage collection, uint256 cursor, uint256 perPage)\\n    internal view returns(LibFastHistory.SupplyProof[] memory, uint256) {\\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n      LibFastHistory.SupplyProof[] memory values = new LibFastHistory.SupplyProof[](length);\\n      for (uint256 i = 0; i < length; i++) {\\n        values[i] = collection[cursor + i];\\n      }\\n      return (values, cursor + length);\\n  }\\n\\n  function transferProofs(LibFastHistory.TransferProof[] storage collection, uint256 cursor, uint256 perPage)\\n    internal view returns(LibFastHistory.TransferProof[] memory, uint256) {\\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n      LibFastHistory.TransferProof[] memory values = new LibFastHistory.TransferProof[](length);\\n      for (uint256 i = 0; i < length; i++) {\\n        values[i] = collection[cursor + i];\\n      }\\n      return (values, cursor + length);\\n  }\\n}\",\"keccak256\":\"0xedbf24531aa1b21a17a7962b2053fe1bd81ddf9e8869f508f14f7fb9087631d9\",\"license\":\"MIT\"},\"contracts/spc/SpcTopFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport '../lib/LibHelpers.sol';\\nimport '../interfaces/IHasMembers.sol';\\nimport '../fast/FastTopFacet.sol';\\nimport '../fast/FastTokenFacet.sol';\\nimport './lib/ASpcFacet.sol';\\nimport './lib/LibSpc.sol';\\n\\n\\n/** @title The SPC Smart Contract.\\n *  @dev The SPC contract is the central place for top-level governorship. It requires that a\\n *        first member address is passed at construction time.\\n */\\ncontract SpcTopFacet is ASpcFacet, IHasMembers {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  // Constants.\\n\\n  // This represents how much Eth we provision new SPC members with.\\n  uint256 constant private MEMBER_ETH_PROVISION = 10 ether;\\n  // This represents how much Eth new FASTs are provisioned with.\\n  uint256 constant private FAST_ETH_PROVISION = 250 ether;\\n\\n  // Events.\\n\\n  /** @dev Emited when a new FAST is registered.\\n   *  @param fast The address of the newly registered FAST diamond.\\n   */\\n  event FastRegistered(address indexed fast);\\n\\n  /** @dev Emited when someone provisions this SPC with Eth.\\n   *  @param from The sender of the Eth.\\n   *  @param amount The quantity of Eth, expressed in Wei.\\n   */\\n  event EthReceived(address indexed from, uint256 amount);\\n  /** @dev Emited when Eth is drained from this SPC.\\n   *  @param to The caller and recipient of the drained Eth.\\n   *  @param amount The quantity of Eth that was drained, expressed in Wei.\\n   */\\n  event EthDrained(address indexed to, uint256 amount);\\n\\n  // Eth provisioning stuff.\\n\\n  /** @dev A function that alllows provisioning this SPC with Eth.\\n   *  @notice Emits a `EthReceived` event.\\n   */\\n  function provisionWithEth()\\n      external payable {\\n    require(msg.value > 0, LibConstants.MISSING_ATTACHED_ETH);\\n    emit EthReceived(msg.sender, msg.value);\\n  }\\n\\n  /** @dev A function that alllows draining this SPC from its Eth.\\n   *  @notice Requires that the caller is a member of this SPC.\\n   *  @notice Emits a `EthDrained` event.\\n   */\\n  function drainEth()\\n      external\\n      membership(msg.sender) {\\n    uint256 amount = payable(address(this)).balance;\\n    payable(msg.sender).transfer(amount);\\n    emit EthDrained(msg.sender, amount);\\n  }\\n\\n  // Membership management.\\n\\n  /** @dev Queries whether a given address is a member of this SPC or not.\\n   *  @param candidate The address to test.\\n   *  @return A `boolean` flag.\\n   */\\n  function isMember(address candidate)\\n      external override view returns(bool) {\\n    return LibSpc.data().memberSet.contains(candidate);\\n  }\\n\\n  /** @dev Counts the numbers of members present in this SPC.\\n   *  @return The number of members in this SPC.\\n   */\\n  function memberCount()\\n      external override view returns(uint256) {\\n    return LibSpc.data().memberSet.values.length;\\n  }\\n\\n  /** @dev Paginates the members of this SPC based on a starting cursor and a number of records per page.\\n   *  @param cursor The index at which to start.\\n   *  @param perPage How many records should be returned at most.\\n   *  @return A `address[]` list of values at most `perPage` big.\\n   *  @return A `uint256` index to the next page.\\n   */\\n  function paginateMembers(uint256 cursor, uint256 perPage)\\n      external override view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibSpc.data().memberSet.values, cursor, perPage);\\n  }\\n\\n  /** @dev Adds a member to this SPC member list.\\n   *  @param member The address of the member to be added.\\n   *  @notice Requires that the caller is a member of this SPC.\\n   *  @notice Emits a `IHasMembers.MemberAdded` event.\\n   */\\n  function addMember(address payable member)\\n      external override\\n      membership(msg.sender) {\\n    // Add the member to our list.\\n    LibSpc.data().memberSet.add(member, false);\\n\\n    // Provision the member with some Eth.\\n    uint256 amount = LibHelpers.upTo(member, MEMBER_ETH_PROVISION);\\n    if (amount != 0) { member.transfer(amount); }\\n\\n    // Emit!\\n    emit IHasMembers.MemberAdded(member);\\n  }\\n\\n  /** @dev Removes a member from this SPC.\\n   *  @param member The address of the member to be removed.\\n   *  @notice Requires that the caller is a member of this SPC.\\n   *  @notice Emits a `IHasMembers.MemberRemoved` event.\\n   */\\n  function removeMember(address member)\\n      external override\\n      membership(msg.sender) {\\n    // No suicide allowed.\\n    require(msg.sender != member, 'Cannot remove self');\\n    // Remove the member from the set.\\n    LibSpc.data().memberSet.remove(member, false);\\n    // Emit!\\n    emit IHasMembers.MemberRemoved(member);\\n  }\\n\\n  // FAST management related methods.\\n\\n  /** @dev Queries whether a given address is a known and registered FAST contract.\\n   * @param fast The address of the contract to check.\\n   * @return A boolean.\\n   */\\n  function isFastRegistered(address fast)\\n      external view returns(bool) {\\n    return LibSpc.data().fastSet.contains(fast);\\n  }\\n\\n  /** @dev Allows to retrieve the address of a FAST diamond given its symbol.\\n   *  @param symbol The symbol of the FAST diamond to get the address of.\\n   *  @return The address of the corresponding FAST diamond, or the Zero Address if not found.\\n   */\\n  function fastBySymbol(string calldata symbol)\\n      external view returns(address) {\\n    return LibSpc.data().fastSymbols[symbol];\\n  }\\n\\n  /** @dev Allows the registration of a given FAST diamond with this SPC.\\n   *  @param fast The address of the FAST diamond to be registered.\\n   *  @notice Requires that the caller is a member of this SPC.\\n   *  @notice Emits a `FastRegistered` event.\\n   */\\n  function registerFast(address fast)\\n      external\\n      membership(msg.sender) {\\n    LibSpc.Data storage s = LibSpc.data();\\n    string memory symbol = FastTokenFacet(fast).symbol();\\n    require(s.fastSymbols[symbol] == address(0), LibConstants.DUPLICATE_ENTRY);\\n\\n    // Add the FAST to our list.\\n    s.fastSet.add(fast, false);\\n    // Add the fast symbol to our list.\\n    s.fastSymbols[symbol] = fast;\\n\\n    // Provision the new fast with Eth.\\n    uint256 amount = LibHelpers.upTo(payable(fast), FAST_ETH_PROVISION);\\n    // Only provision the fast if possible.\\n    if (amount > 0) {\\n      FastTopFacet(fast).provisionWithEth{ value: amount }();\\n    }\\n    // Emit!\\n    emit FastRegistered(fast);\\n  }\\n\\n  /** @dev Counts the number of FAST diamonds registered with this SPC.\\n   *  @return The number of FAST diamonds registered with this SPC.\\n   */\\n  function fastCount()\\n      external view returns(uint256) {\\n    return LibSpc.data().fastSet.values.length;\\n  }\\n\\n  /** @dev Paginates the FAST diamonds registered with this SPC based on a starting cursor and a number of records per page.\\n   *  @param cursor The index at which to start.\\n   *  @param perPage How many records should be returned at most.\\n   *  @return A `address[]` list of values at most `perPage` big.\\n   *  @return A `uint256` index to the next page.\\n   */\\n  function paginateFasts(uint256 cursor, uint256 perPage)\\n      external view\\n      returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibSpc.data().fastSet.values, cursor, perPage);\\n  }\\n}\\n\",\"keccak256\":\"0x3b549112526d2dd82ce4ab879ba940a9f7f512e026cdee91a6dc6d9534fe29cb\",\"license\":\"MIT\"},\"contracts/spc/lib/ASpcFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibConstants.sol';\\nimport '../../lib/LibAddressSet.sol';\\nimport '../../interfaces/IERC173.sol';\\nimport '../lib/LibSpc.sol';\\n\\n\\n/**\\n* @dev This contract is a group of modifiers that can be used by any facets to guard against\\n*       certain permissions.\\n*/\\nabstract contract ASpcFacet {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  /// Modifiers.\\n\\n  /// @dev Ensures that a method can only be called by another facet of the same diamond.\\n  modifier diamondInternal() {\\n    require(msg.sender == address(this), LibConstants.INTERNAL_METHOD);\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the owner of this diamond.\\n  modifier diamondOwner() {\\n    require(msg.sender == IERC173(address(this)).owner(), LibConstants.REQUIRES_DIAMOND_OWNERSHIP);\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the singleton deployer contract factory.\\n  modifier deployerContract() {\\n    require(msg.sender == LibConstants.DEPLOYER_CONTRACT, LibConstants.INTERNAL_METHOD);\\n    _;\\n  }\\n\\n  /// @dev Ensures that the given address is a member of the current FAST.\\n  modifier membership(address a) {\\n    require(LibSpc.data().memberSet.contains(a), LibConstants.REQUIRES_SPC_MEMBERSHIP);\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x61e5365b6a0491b38d1f3bd59af0b2c882681b471dc86039698c734a212757f6\",\"license\":\"MIT\"},\"contracts/spc/lib/LibSpc.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\n\\nlibrary LibSpc {\\n  // These are from IHasMembers.\\n  event MemberAdded(address indexed member);\\n\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Spc.storage'):\\n  bytes32 internal constant STORAGE_SLOT = 0x89a652f66ca129ef71cab44916bb070742a08af428e08a99df145c8006c94285;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    // This is where we hold our members data.\\n    LibAddressSet.Data memberSet;\\n    // This is where we keep our list of deployed fast FASTs.\\n    LibAddressSet.Data fastSet;\\n    // We keep track of the FAST symbols that were already used.\\n    mapping(string => address) fastSymbols;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0x95acfb97e7269758dfaac36bac10782b6a6bb17c75d151c2c4fdea0fbeaa1a67\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061100d806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80631dda7d8f14610030575b600080fd5b61004a60048036038101906100459190610cdf565b61004c565b005b736df2d25d8c6fd680730ee658b530a05a99bb769a73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146040518060400160405280600f81526020017f496e7465726e616c206d6574686f64000000000000000000000000000000000081525090610106576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016100fd9190610d9f565b60405180910390fd5b5060006101116108ec565b9050600161ffff168160000160009054906101000a900461ffff1661ffff1610610170576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161016790610de1565b60405180910390fd5b60018160000160006101000a81548161ffff021916908361ffff160217905550600061019a610914565b905060018160030160007f36372b07000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007f01ffc9a7000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007f7f5828d0000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007fab84a5c8000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007f1f931c1c000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007f48e2b093000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007f84378070000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007fb4bb4f46000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555082600001602081019061060f9190610c8d565b8260000160026101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508260200160208101906106649190610c8d565b8260010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060006106b0610941565b905060018160000160006101000a81548161ffff021916908361ffff1602179055506106fd8460400160208101906106e89190610c8d565b6000836003016109699092919063ffffffff16565b6107288460400160208101906107139190610c8d565b6000836001016109699092919063ffffffff16565b83604001602081019061073b9190610c8d565b73ffffffffffffffffffffffffffffffffffffffff167fdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b560405160405180910390a28360400160208101906107909190610c8d565b73ffffffffffffffffffffffffffffffffffffffff167fb251eb052afc73ffd02ffe85ad79990a8b3fed60d76dbc2fa2fdd7123dffd91460405160405180910390a260006107dc610a86565b905060018160000160006101000a81548161ffff021916908361ffff16021790555084806060019061080e9190610e01565b86806080019061081e9190610e01565b8860a0013585600101600087600201600089600301600086919050558686909192909192509190610850929190610ba4565b508686909192909192509190610867929190610ba4565b505050505050600081600401819055508460c001602081019061088a9190610cb6565b8560e001602081019061089d9190610cb6565b8260060160018460060160008491906101000a81548160ff0219169083151502179055508391906101000a81548160ff0219169083151502179055505050600081600501819055505050505050565b60007f80c187ea6f955fd624c41fb7a18011cc87d98c6f4c06d897b59142f65707e705905090565b6000807fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c90508091505090565b60007f87ed8063ac9ead3b2eb7551ed3d89b29fcbf44d6733084b5c82e95d5120ece9a905090565b60006109758484610aae565b90508180156109815750805b1561098c5750610a81565b80156109cd576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109c490610dc1565b60405180910390fd5b83600101805490508460000160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555083600101839080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550505b505050565b60007fb098747b87c5c0e2a32eb9b06725e9bad4263809bcda628ceadc1a686bcb8261905090565b600080836001018054905014610b99578173ffffffffffffffffffffffffffffffffffffffff16836001018460000160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205481548110610b52577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610b9c565b60005b905092915050565b828054610bb090610ee5565b90600052602060002090601f016020900481019282610bd25760008555610c19565b82601f10610beb57803560ff1916838001178555610c19565b82800160010185558215610c19579182015b82811115610c18578235825591602001919060010190610bfd565b5b509050610c269190610c2a565b5090565b5b80821115610c43576000816000905550600101610c2b565b5090565b600081359050610c5681610fa9565b92915050565b600081359050610c6b81610fc0565b92915050565b60006101008284031215610c8457600080fd5b81905092915050565b600060208284031215610c9f57600080fd5b6000610cad84828501610c47565b91505092915050565b600060208284031215610cc857600080fd5b6000610cd684828501610c5c565b91505092915050565b600060208284031215610cf157600080fd5b600082013567ffffffffffffffff811115610d0b57600080fd5b610d1784828501610c71565b91505092915050565b6000610d2b82610e58565b610d358185610e63565b9350610d45818560208601610eb2565b610d4e81610f46565b840191505092915050565b6000610d66601683610e63565b9150610d7182610f57565b602082019050919050565b6000610d89601383610e63565b9150610d9482610f80565b602082019050919050565b60006020820190508181036000830152610db98184610d20565b905092915050565b60006020820190508181036000830152610dda81610d59565b9050919050565b60006020820190508181036000830152610dfa81610d7c565b9050919050565b60008083356001602003843603038112610e1a57600080fd5b80840192508235915067ffffffffffffffff821115610e3857600080fd5b602083019250600182023603831315610e5057600080fd5b509250929050565b600081519050919050565b600082825260208201905092915050565b6000610e7f82610e92565b9050919050565b60008115159050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60005b83811015610ed0578082015181840152602081019050610eb5565b83811115610edf576000848401525b50505050565b60006002820490506001821680610efd57607f821691505b60208210811415610f1157610f10610f17565b5b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b6000601f19601f8301169050919050565b7f4164647265737320616c726561647920696e2073657400000000000000000000600082015250565b7f416c726561647920696e697469616c697a656400000000000000000000000000600082015250565b610fb281610e74565b8114610fbd57600080fd5b50565b610fc981610e86565b8114610fd457600080fd5b5056fea26469706673582212204cf8cf6eaab1514c9dbc664dd178eef7daa9802f91d8cef86dc475d60dcc05cc64736f6c63430008040033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c80631dda7d8f14610030575b600080fd5b61004a60048036038101906100459190610cdf565b61004c565b005b736df2d25d8c6fd680730ee658b530a05a99bb769a73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146040518060400160405280600f81526020017f496e7465726e616c206d6574686f64000000000000000000000000000000000081525090610106576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016100fd9190610d9f565b60405180910390fd5b5060006101116108ec565b9050600161ffff168160000160009054906101000a900461ffff1661ffff1610610170576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161016790610de1565b60405180910390fd5b60018160000160006101000a81548161ffff021916908361ffff160217905550600061019a610914565b905060018160030160007f36372b07000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007f01ffc9a7000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007f7f5828d0000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007fab84a5c8000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007f1f931c1c000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007f48e2b093000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007f84378070000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007fb4bb4f46000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555082600001602081019061060f9190610c8d565b8260000160026101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508260200160208101906106649190610c8d565b8260010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060006106b0610941565b905060018160000160006101000a81548161ffff021916908361ffff1602179055506106fd8460400160208101906106e89190610c8d565b6000836003016109699092919063ffffffff16565b6107288460400160208101906107139190610c8d565b6000836001016109699092919063ffffffff16565b83604001602081019061073b9190610c8d565b73ffffffffffffffffffffffffffffffffffffffff167fdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b560405160405180910390a28360400160208101906107909190610c8d565b73ffffffffffffffffffffffffffffffffffffffff167fb251eb052afc73ffd02ffe85ad79990a8b3fed60d76dbc2fa2fdd7123dffd91460405160405180910390a260006107dc610a86565b905060018160000160006101000a81548161ffff021916908361ffff16021790555084806060019061080e9190610e01565b86806080019061081e9190610e01565b8860a0013585600101600087600201600089600301600086919050558686909192909192509190610850929190610ba4565b508686909192909192509190610867929190610ba4565b505050505050600081600401819055508460c001602081019061088a9190610cb6565b8560e001602081019061089d9190610cb6565b8260060160018460060160008491906101000a81548160ff0219169083151502179055508391906101000a81548160ff0219169083151502179055505050600081600501819055505050505050565b60007f80c187ea6f955fd624c41fb7a18011cc87d98c6f4c06d897b59142f65707e705905090565b6000807fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c90508091505090565b60007f87ed8063ac9ead3b2eb7551ed3d89b29fcbf44d6733084b5c82e95d5120ece9a905090565b60006109758484610aae565b90508180156109815750805b1561098c5750610a81565b80156109cd576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109c490610dc1565b60405180910390fd5b83600101805490508460000160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555083600101839080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550505b505050565b60007fb098747b87c5c0e2a32eb9b06725e9bad4263809bcda628ceadc1a686bcb8261905090565b600080836001018054905014610b99578173ffffffffffffffffffffffffffffffffffffffff16836001018460000160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205481548110610b52577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610b9c565b60005b905092915050565b828054610bb090610ee5565b90600052602060002090601f016020900481019282610bd25760008555610c19565b82601f10610beb57803560ff1916838001178555610c19565b82800160010185558215610c19579182015b82811115610c18578235825591602001919060010190610bfd565b5b509050610c269190610c2a565b5090565b5b80821115610c43576000816000905550600101610c2b565b5090565b600081359050610c5681610fa9565b92915050565b600081359050610c6b81610fc0565b92915050565b60006101008284031215610c8457600080fd5b81905092915050565b600060208284031215610c9f57600080fd5b6000610cad84828501610c47565b91505092915050565b600060208284031215610cc857600080fd5b6000610cd684828501610c5c565b91505092915050565b600060208284031215610cf157600080fd5b600082013567ffffffffffffffff811115610d0b57600080fd5b610d1784828501610c71565b91505092915050565b6000610d2b82610e58565b610d358185610e63565b9350610d45818560208601610eb2565b610d4e81610f46565b840191505092915050565b6000610d66601683610e63565b9150610d7182610f57565b602082019050919050565b6000610d89601383610e63565b9150610d9482610f80565b602082019050919050565b60006020820190508181036000830152610db98184610d20565b905092915050565b60006020820190508181036000830152610dda81610d59565b9050919050565b60006020820190508181036000830152610dfa81610d7c565b9050919050565b60008083356001602003843603038112610e1a57600080fd5b80840192508235915067ffffffffffffffff821115610e3857600080fd5b602083019250600182023603831315610e5057600080fd5b509250929050565b600081519050919050565b600082825260208201905092915050565b6000610e7f82610e92565b9050919050565b60008115159050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60005b83811015610ed0578082015181840152602081019050610eb5565b83811115610edf576000848401525b50505050565b60006002820490506001821680610efd57607f821691505b60208210811415610f1157610f10610f17565b5b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b6000601f19601f8301169050919050565b7f4164647265737320616c726561647920696e2073657400000000000000000000600082015250565b7f416c726561647920696e697469616c697a656400000000000000000000000000600082015250565b610fb281610e74565b8114610fbd57600080fd5b50565b610fc981610e86565b8114610fd457600080fd5b5056fea26469706673582212204cf8cf6eaab1514c9dbc664dd178eef7daa9802f91d8cef86dc475d60dcc05cc64736f6c63430008040033",
  "devdoc": {
    "details": "Note that although this contract doesn't explicitelly inherit from IERC173, ERC165, IDiamondLoupe etc, all       methods are in fact implemented by the underlaying Diamond proxy. It is therefore safe to       perform casts directly on the current contract address into these interfaces.",
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}