{
  "address": "0x8889BD3df1F1848F892dD7e995c81eC95379F4A4",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "name": "InterfaceNotSupported",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "who",
          "type": "address"
        }
      ],
      "name": "RequiresForwarderManager",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "ref",
          "type": "string"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "who",
          "type": "address"
        }
      ],
      "name": "Burnt",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "basisPointFee",
          "type": "uint32"
        }
      ],
      "name": "CrowdfundDefaultBasisPointFeeSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract Crowdfund",
          "name": "crowdfund",
          "type": "address"
        }
      ],
      "name": "CrowdfundDeployed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract Crowdfund",
          "name": "crowdfund",
          "type": "address"
        }
      ],
      "name": "CrowdfundRemoved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bool",
          "name": "transfersDisabled",
          "type": "bool"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "crowdfundsDefaultBasisPointsFee",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "memberCount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "governorCount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "totalSupply",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "reserveBalance",
          "type": "uint256"
        }
      ],
      "name": "DetailsChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "Disapproval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract Distribution",
          "name": "distribution",
          "type": "address"
        }
      ],
      "name": "DistributionDeployed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract Distribution",
          "name": "distribution",
          "type": "address"
        }
      ],
      "name": "DistributionRemoved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "ref",
          "type": "string"
        }
      ],
      "name": "FastTransfer",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "forwarderAddress",
          "type": "address"
        }
      ],
      "name": "ForwarderChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "ref",
          "type": "string"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "who",
          "type": "address"
        }
      ],
      "name": "Minted",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "getTrustedForwarder",
      "outputs": [
        {
          "internalType": "address",
          "name": "forwarderAddress",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_forwarderAddress",
          "type": "address"
        }
      ],
      "name": "isTrustedForwarder",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_forwarderAddress",
          "type": "address"
        }
      ],
      "name": "setTrustedForwarder",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x53f61b7899ecdd4952959de1f5c12e7382cf04951ee3dec93fed250273ae81cb",
  "receipt": {
    "to": "0x914d7Fec6aaC8cd542e72Bca78B30650d45643d7",
    "from": "0x717634cfe06FFAB2CEAA7fcf1b9019813f4B25FE",
    "contractAddress": null,
    "transactionIndex": 0,
    "gasUsed": "301358",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000008000000000000000010000000000000000000000000000000040000000800000000000000000000100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000004000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004000000000000000000001000000000000000000000000000000100000000000000000000000000000000400010000000000000000000000000000000000100000",
    "blockHash": "0xb8031cf1ea204e6be4fc44db409b66cc5b3e7375fa50249620c64988da444619",
    "transactionHash": "0x53f61b7899ecdd4952959de1f5c12e7382cf04951ee3dec93fed250273ae81cb",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 5461355,
        "transactionHash": "0x53f61b7899ecdd4952959de1f5c12e7382cf04951ee3dec93fed250273ae81cb",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000717634cfe06ffab2ceaa7fcf1b9019813f4b25fe",
          "0x00000000000000000000000009207a6efee346cb3e4a54ac18523e3715d38b3f"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000011215608a4c0000000000000000000000000000000000000000000000000000afbd98b231e4f300000000000000000000000000000000000000000000003f348e0dc1f3d7741100000000000000000000000000000000000000000000000000aeab8351a798f300000000000000000000000000000000000000000000003f348f1fd75461c011",
        "logIndex": 0,
        "blockHash": "0xb8031cf1ea204e6be4fc44db409b66cc5b3e7375fa50249620c64988da444619"
      }
    ],
    "blockNumber": 5461355,
    "cumulativeGasUsed": "301358",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "db2959aae9c17321f9d88ad51d32de96",
  "metadata": "{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"InterfaceNotSupported\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"RequiresForwarderManager\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"ref\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"Burnt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"basisPointFee\",\"type\":\"uint32\"}],\"name\":\"CrowdfundDefaultBasisPointFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract Crowdfund\",\"name\":\"crowdfund\",\"type\":\"address\"}],\"name\":\"CrowdfundDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract Crowdfund\",\"name\":\"crowdfund\",\"type\":\"address\"}],\"name\":\"CrowdfundRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"transfersDisabled\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"crowdfundsDefaultBasisPointsFee\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"memberCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"governorCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserveBalance\",\"type\":\"uint256\"}],\"name\":\"DetailsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Disapproval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract Distribution\",\"name\":\"distribution\",\"type\":\"address\"}],\"name\":\"DistributionDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract Distribution\",\"name\":\"distribution\",\"type\":\"address\"}],\"name\":\"DistributionRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"ref\",\"type\":\"string\"}],\"name\":\"FastTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"forwarderAddress\",\"type\":\"address\"}],\"name\":\"ForwarderChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"ref\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"getTrustedForwarder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"forwarderAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_forwarderAddress\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_forwarderAddress\",\"type\":\"address\"}],\"name\":\"setTrustedForwarder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"RequiresForwarderManager(address)\":[{\"params\":{\"who\":\"is the address that called the function.\"}}]},\"kind\":\"dev\",\"methods\":{\"getTrustedForwarder()\":{\"returns\":{\"forwarderAddress\":\"The address of the Forwarder contract that is being used.\"}},\"isTrustedForwarder(address)\":{\"params\":{\"_forwarderAddress\":\"the forwarder address.\"},\"returns\":{\"_0\":\"bool if the forwarder is trusted.\"}},\"setTrustedForwarder(address)\":{\"params\":{\"_forwarderAddress\":\"the forwarder address.\"}}},\"title\":\"The Fast forwardable contract.\",\"version\":1},\"userdoc\":{\"errors\":{\"RequiresForwarderManager(address)\":[{\"notice\":\"Happens when a function is called by a non forwarder manager.\"}]},\"events\":{\"Burnt(uint256,string,address)\":{\"notice\":\"Emited whenever an burning happens in a FAST.\"},\"CrowdfundDeployed(address)\":{\"notice\":\"Crowdfund related events.\"},\"DetailsChanged(bool,uint32,uint256,uint256,uint256,uint256)\":{\"notice\":\"This is an event that is fired whenever any of some of the FAST parameters change, so that the frontend can react to it and refresh the general header for that fast as well as the baseball cards in the FASTs list.\"},\"Disapproval(address,address,uint256)\":{\"notice\":\"See `ERC20.Disapproval`.\"},\"DistributionDeployed(address)\":{\"notice\":\"Distribution related events.\"},\"FastTransfer(address,address,address,uint256,string)\":{\"notice\":\"As we augmented the ERC20 standard with a few concepts, we emit our custom events in addition to the ERC20 ones.\"},\"ForwarderChanged(address)\":{\"notice\":\"Emited when a forwarder is set on an implementing contract.\"},\"Minted(uint256,string,address)\":{\"notice\":\"Emited whenever an issuance happens in a FAST.\"}},\"kind\":\"user\",\"methods\":{\"getTrustedForwarder()\":{\"notice\":\"WARNING: The Forwarder can have a full control over your Recipient. Only trust verified Forwarder.Method is not a required method to allow Recipients to trust multiple Forwarders. Not recommended yet.\"},\"isTrustedForwarder(address)\":{\"notice\":\"ERC2771Recipient implementation.\"},\"setTrustedForwarder(address)\":{\"notice\":\"ERC2771Recipient implementation.\"}},\"notice\":\"The Fast Forwardable facet is in charge of \\\"gasless transactions\\\".\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/fast/FastForwardableFacet.sol\":\"FastForwardableFacet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[]},\"sources\":{\"@opengsn/contracts/src/forwarder/IForwarder.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >=0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\n\\n/**\\n * @title The Forwarder Interface\\n * @notice The contracts implementing this interface take a role of authorization, authentication and replay protection\\n * for contracts that choose to trust a `Forwarder`, instead of relying on a mechanism built into the Ethereum protocol.\\n *\\n * @notice if the `Forwarder` contract decides that an incoming `ForwardRequest` is valid, it must append 20 bytes that\\n * represent the caller to the `data` field of the request and send this new data to the target address (the `to` field)\\n *\\n * :warning: **Warning** :warning: The Forwarder can have a full control over a `Recipient` contract.\\n * Any vulnerability in a `Forwarder` implementation can make all of its `Recipient` contracts susceptible!\\n * Recipient contracts should only trust forwarders that passed through security audit,\\n * otherwise they are susceptible to identity theft.\\n */\\ninterface IForwarder is IERC165 {\\n\\n    /**\\n     * @notice A representation of a request for a `Forwarder` to send `data` on behalf of a `from` to a target (`to`).\\n     */\\n    struct ForwardRequest {\\n        address from;\\n        address to;\\n        uint256 value;\\n        uint256 gas;\\n        uint256 nonce;\\n        bytes data;\\n        uint256 validUntilTime;\\n    }\\n\\n    event DomainRegistered(bytes32 indexed domainSeparator, bytes domainValue);\\n\\n    event RequestTypeRegistered(bytes32 indexed typeHash, string typeStr);\\n\\n    /**\\n     * @param from The address of a sender.\\n     * @return The nonce for this address.\\n     */\\n    function getNonce(address from)\\n    external view\\n    returns(uint256);\\n\\n    /**\\n     * @notice Verify the transaction is valid and can be executed.\\n     * Implementations must validate the signature and the nonce of the request are correct.\\n     * Does not revert and returns successfully if the input is valid.\\n     * Reverts if any validation has failed. For instance, if either signature or nonce are incorrect.\\n     * Reverts if `domainSeparator` or `requestTypeHash` are not registered as well.\\n     */\\n    function verify(\\n        ForwardRequest calldata forwardRequest,\\n        bytes32 domainSeparator,\\n        bytes32 requestTypeHash,\\n        bytes calldata suffixData,\\n        bytes calldata signature\\n    ) external view;\\n\\n    /**\\n     * @notice Executes a transaction specified by the `ForwardRequest`.\\n     * The transaction is first verified and then executed.\\n     * The success flag and returned bytes array of the `CALL` are returned as-is.\\n     *\\n     * This method would revert only in case of a verification error.\\n     *\\n     * All the target errors are reported using the returned success flag and returned bytes array.\\n     *\\n     * @param forwardRequest All requested transaction parameters.\\n     * @param domainSeparator The domain used when signing this request.\\n     * @param requestTypeHash The request type used when signing this request.\\n     * @param suffixData The ABI-encoded extension data for the current `RequestType` used when signing this request.\\n     * @param signature The client signature to be validated.\\n     *\\n     * @return success The success flag of the underlying `CALL` to the target address.\\n     * @return ret The byte array returned by the underlying `CALL` to the target address.\\n     */\\n    function execute(\\n        ForwardRequest calldata forwardRequest,\\n        bytes32 domainSeparator,\\n        bytes32 requestTypeHash,\\n        bytes calldata suffixData,\\n        bytes calldata signature\\n    )\\n    external payable\\n    returns (bool success, bytes memory ret);\\n\\n    /**\\n     * @notice Register a new Request typehash.\\n     *\\n     * @notice This is necessary for the Forwarder to be able to verify the signatures conforming to the ERC-712.\\n     *\\n     * @param typeName The name of the request type.\\n     * @param typeSuffix Any extra data after the generic params. Must contain add at least one param.\\n     * The generic ForwardRequest type is always registered by the constructor.\\n     */\\n    function registerRequestType(string calldata typeName, string calldata typeSuffix) external;\\n\\n    /**\\n     * @notice Register a new domain separator.\\n     *\\n     * @notice This is necessary for the Forwarder to be able to verify the signatures conforming to the ERC-712.\\n     *\\n     * @notice The domain separator must have the following fields: `name`, `version`, `chainId`, `verifyingContract`.\\n     * The `chainId` is the current network's `chainId`, and the `verifyingContract` is this Forwarder's address.\\n     * This method accepts the domain name and version to create and register the domain separator value.\\n     * @param name The domain's display name.\\n     * @param version The domain/protocol version.\\n     */\\n    function registerDomainSeparator(string calldata name, string calldata version) external;\\n}\\n\",\"keccak256\":\"0x28669953bd3dcc98a5f959fa3cac97444584b6fbe59341681b9a59f11a83b171\",\"license\":\"GPL-3.0-only\"},\"@openzeppelin/contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\",\"keccak256\":\"0xd04b0f06e0666f29cf7cccc82894de541e19bb30a765b107b1e40bb7fe5f7d7a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\n\",\"keccak256\":\"0x6ebf1944ab804b8660eb6fc52f9fe84588cee01c2566a69023e59497e7d27f45\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"contracts/common/AHasAutomatons.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport \\\"../lib/LibAddressSet.sol\\\";\\nimport \\\"../lib/LibPaginate.sol\\\";\\nimport \\\"./lib/LibHasAutomatons.sol\\\";\\n\\n/**\\n * @title The Fast Smart Contract.\\n * @notice The Fast Automatons abstract contract is in charge of keeping track of automaton accounts.\\n */\\nabstract contract AHasAutomatons {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  /// Errors.\\n\\n  error RequiresAutomatonsManager(address who);\\n\\n  /// Events.\\n\\n  /**\\n   * @notice Emited when an automaton is added or changed.\\n   * @param automaton is the address of the automaton.\\n   * @param privileges is the new bitfield assigned to this automaton.\\n   */\\n  event AutomatonPrivilegesSet(address indexed automaton, uint32 indexed privileges);\\n\\n  /**\\n   * @notice Emited when an automaton is removed.\\n   * @param automaton is the address of the removed automaton.\\n   */\\n  event AutomatonRemoved(address indexed automaton);\\n\\n  // Must be overriden.\\n  function isAutomatonsManager(address who) internal view virtual returns (bool);\\n\\n  // May be overriden.\\n  function onAutomatonAdded(address member) internal virtual {}\\n\\n  // May be overriden.\\n  function onAutomatonRemoved(address member) internal virtual {}\\n\\n  /// Automatons management.\\n\\n  /**\\n   * @notice Queries whether a given address is an automaton for this Fast or not.\\n   * @param candidate is the address to test.\\n   * @return A `boolean` flag.\\n   */\\n  function isAutomaton(address candidate) external view returns (bool) {\\n    return LibHasAutomatons.data().automatonSet.contains(candidate);\\n  }\\n\\n  /**\\n   * @notice Returns the privileges for a given automaton address, or zero if no privileges exist.\\n   * @param automaton is the address to test.\\n   * @return An `uint256` bitfield.\\n   */\\n  function automatonPrivileges(address automaton) external view returns (uint32) {\\n    return LibHasAutomatons.data().automatonPrivileges[automaton];\\n  }\\n\\n  function automatonCan(address automaton, uint32 privilege) external view returns (bool) {\\n    return (LibHasAutomatons.data().automatonPrivileges[automaton] & privilege) != 0;\\n  }\\n\\n  /**\\n   * @notice Counts the numbers of automatons present in this Fast.\\n   * @return The number of automatons in this marketplace.\\n   */\\n  function automatonCount() external view returns (uint256) {\\n    return LibHasAutomatons.data().automatonSet.values.length;\\n  }\\n\\n  /**\\n   * @notice Paginates the automatons of this Fast based on a starting cursor and a number of records per page.\\n   * @param cursor is the index at which to start.\\n   * @param perPage is how many records should be returned at most.\\n   * @return A `address[]` list of values at most `perPage` big.\\n   * @return A `uint256` index to the next page.\\n   */\\n  function paginateAutomatons(uint256 cursor, uint256 perPage) external view returns (address[] memory, uint256) {\\n    return LibPaginate.addresses(LibHasAutomatons.data().automatonSet.values, cursor, perPage);\\n  }\\n\\n  /**\\n   * @notice Sets privileges for a given automaton address.\\n   * @param candidate is the automaton address to which the privileges should be assigned.\\n   * @param privileges is a bitfield of privileges to apply.\\n   */\\n  function setAutomatonPrivileges(address candidate, uint32 privileges) external onlyAutomatonManager(msg.sender) {\\n    LibHasAutomatons.Data storage ds = LibHasAutomatons.data();\\n    ds.automatonSet.add(candidate, true);\\n    ds.automatonPrivileges[candidate] = privileges;\\n    emit AutomatonPrivilegesSet(candidate, privileges);\\n  }\\n\\n  /**\\n   * @notice Removes an automaton completely.\\n   * @param candidate is the automaton to remove.\\n   */\\n  function removeAutomaton(address candidate) external onlyAutomatonManager(msg.sender) {\\n    LibHasAutomatons.Data storage ds = LibHasAutomatons.data();\\n    ds.automatonSet.remove(candidate, false);\\n    delete ds.automatonPrivileges[candidate];\\n    emit AutomatonRemoved(candidate);\\n  }\\n\\n  /// Modifiers.\\n\\n  modifier onlyAutomatonManager(address who) {\\n    if (!isAutomatonsManager(who)) revert RequiresAutomatonsManager(who);\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x32b378bdd83c63676854bbc408fbeea2471ba3821c888ec8703a963cbf5b4030\",\"license\":\"MIT\"},\"contracts/common/AHasForwarder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport \\\"./lib/LibHasForwarder.sol\\\";\\nimport \\\"../interfaces/ICustomErrors.sol\\\";\\nimport \\\"../interfaces/IERC165.sol\\\"; // Interface Support.\\n\\nimport \\\"@opengsn/contracts/src/forwarder/IForwarder.sol\\\";\\n\\n/**\\n * @title The Forwarder behaviour abstract contract.\\n * @notice The AHasForwarder abstract contract is in charge of adding the Forwarder\\n *         functionality to any contract inheriting from it.\\n */\\nabstract contract AHasForwarder {\\n  /// Errors.\\n\\n  /**\\n   * @notice Happens when a function is called by a non forwarder manager.\\n   * @param who is the address that called the function.\\n   */\\n  error RequiresForwarderManager(address who);\\n\\n  /// Events.\\n\\n  /**\\n   * @notice Emited when a forwarder is set on an implementing contract.\\n   * @param forwarderAddress is the address of the trusted forwarder.\\n   */\\n  event ForwarderChanged(address forwarderAddress);\\n\\n  // SEE: https://github.com/opengsn/gsn/blob/v3.0.0-beta.10/packages/contracts/src/ERC2771Recipient.sol\\n\\n  /**\\n   * @notice ERC2771Recipient implementation.\\n   * @param _forwarderAddress the forwarder address.\\n   * @return bool if the forwarder is trusted.\\n   */\\n  function isTrustedForwarder(address _forwarderAddress) public view returns (bool) {\\n    return _forwarderAddress == LibHasForwarder.data().forwarderAddress;\\n  }\\n\\n  /**\\n   * @notice ERC2771Recipient implementation.\\n   * @param _forwarderAddress the forwarder address.\\n   */\\n  function setTrustedForwarder(address _forwarderAddress) external onlyForwarderManager {\\n    if (!IERC165(_forwarderAddress).supportsInterface(type(IForwarder).interfaceId))\\n      revert ICustomErrors.InterfaceNotSupported(\\\"IForwarder\\\");\\n\\n    LibHasForwarder.Data storage ds = LibHasForwarder.data();\\n    ds.forwarderAddress = _forwarderAddress;\\n\\n    emit ForwarderChanged(_forwarderAddress);\\n  }\\n\\n  /**\\n   * WARNING: The Forwarder can have a full control over your Recipient. Only trust verified Forwarder.\\n   * @notice Method is not a required method to allow Recipients to trust multiple Forwarders. Not recommended yet.\\n   * @return forwarderAddress The address of the Forwarder contract that is being used.\\n   */\\n  function getTrustedForwarder() public view virtual returns (address forwarderAddress) {\\n    return LibHasForwarder.data().forwarderAddress;\\n  }\\n\\n  /**\\n   * @notice Checks whether the given address is a forwarder manager or not.\\n   * @dev Must be implemented by the inheriting contract.\\n   * @param who is the address to test.\\n   */\\n  function isValidForwarderManager(address who) internal view virtual returns (bool);\\n\\n  /// Modifiers.\\n\\n  /// @notice Ensures that a method can only be called by the forwarder manager.\\n  modifier onlyForwarderManager() virtual {\\n    if (!isValidForwarderManager(msg.sender)) revert RequiresForwarderManager(msg.sender);\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x96bdf4d90ba871d0b6cdc3c4217d02b41e0ef9f71d8fb5579d382cbe75dc71aa\",\"license\":\"MIT\"},\"contracts/common/AHasGovernors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport \\\"../lib/LibAddressSet.sol\\\";\\nimport \\\"../lib/LibPaginate.sol\\\";\\nimport \\\"../interfaces/ICustomErrors.sol\\\";\\nimport \\\"./lib/LibHasGovernors.sol\\\";\\n\\n/**\\n * @title The Fast Smart Contract.\\n * @notice The Fast Governors abstract contract is in charge of keeping track of automaton accounts.\\n */\\nabstract contract AHasGovernors {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  /// Errors.\\n\\n  /// @notice Happens when a function is called by an address that is not a governors manager.\\n  error RequiresGovernorsManager(address who);\\n  /// @notice Happens when an address is used as a governor but is not valid.\\n  error RequiresValidGovernor(address who);\\n\\n  /// Events.\\n\\n  /**\\n   * @notice Emited when a governor is added to the implementing contract.\\n   * @param governor is the address of the added governor.\\n   */\\n  event GovernorAdded(address indexed governor);\\n  /**\\n   * @notice Emited when a governor is removed to the implementing contract.\\n   * @param governor is the address of the removed member.\\n   */\\n  event GovernorRemoved(address indexed governor);\\n\\n  /**\\n   * @notice Default implementation - points to `_msgSender()`.\\n   * @dev May be overriden by the inheriting contract.\\n   */\\n  function _msgSender() internal view virtual returns (address) {\\n    return msg.sender;\\n  }\\n\\n  /**\\n   * @notice Checks whether the caller is a governor manager or not.\\n   * @dev Must be implemented by the inheriting contract.\\n   * @param who is the address to test.\\n   */\\n  function isGovernorsManager(address who) internal view virtual returns (bool);\\n\\n  /**\\n   * @notice Checks whether the given address can be added as a governor or not.\\n   * @dev Must be implemented by the inheriting contract.\\n   * @param who is the address to test.\\n   */\\n  function isValidGovernor(address who) internal view virtual returns (bool);\\n\\n  /**\\n   * @notice This callback is called when a governor is added to the contract.\\n   * @dev May be overriden by the inheriting contract.\\n   * @param governor is the address which was added.\\n   */\\n  function onGovernorAdded(address governor) internal virtual {}\\n\\n  /**\\n   * @notice This callback is called when a governor is removed to the contract.\\n   * @dev May be overriden by the inheriting contract.\\n   * @param governor is the address which was removed.\\n   */\\n  function onGovernorRemoved(address governor) internal virtual {}\\n\\n  // Governors management.\\n\\n  /**\\n   * @notice Queries whether a given address is a governor or not.\\n   * @param who is the address to test.\\n   * @return A `bool` equal to `true` when `candidate` is a governor.\\n   */\\n  function isGovernor(address who) external view returns (bool) {\\n    return LibHasGovernors.data().governorSet.contains(who);\\n  }\\n\\n  /**\\n   * @notice Queries the number of governors.\\n   * @return An `uint256`.\\n   */\\n  function governorCount() external view returns (uint256) {\\n    return LibHasGovernors.data().governorSet.values.length;\\n  }\\n\\n  /**\\n   * @notice Queries pages of governors based on a start index and a page size.\\n   * @param index is the offset at which the pagination operation should start.\\n   * @param perPage is how many items should be returned.\\n   * @return A `(address[], uint256)` tuple, which first item is the list of addresses and the second item a cursor to the next page.\\n   */\\n  function paginateGovernors(uint256 index, uint256 perPage) external view returns (address[] memory, uint256) {\\n    return LibPaginate.addresses(LibHasGovernors.data().governorSet.values, index, perPage);\\n  }\\n\\n  /**\\n   * @notice Adds a governor to the list of known governors.\\n   * @param who is the address to be added.\\n   */\\n  function addGovernor(address who) external onlyGovernorManager(_msgSender()) onlyValidGovernor(who) {\\n    // Add the governor.\\n    LibHasGovernors.data().governorSet.add(who, false);\\n    // Notify via callback.\\n    onGovernorAdded(who);\\n    // Emit!\\n    emit GovernorAdded(who);\\n  }\\n\\n  /**\\n   * @notice Removes a governor from this contract.\\n   * @param governor The address of the governor to be removed.\\n   * @notice Requires that the caller is a governor of this Issuer.\\n   * @notice Emits a `AHasGovernors.GovernorRemoved` event.\\n   */\\n  function removeGovernor(address governor) external onlyGovernorManager(_msgSender()) {\\n    // Notify via callback.\\n    onGovernorRemoved(governor);\\n    // Remove governor.\\n    LibHasGovernors.data().governorSet.remove(governor, false);\\n    // Emit!\\n    emit GovernorRemoved(governor);\\n  }\\n\\n  /// Modifiers.\\n\\n  modifier onlyGovernorManager(address who) {\\n    if (!isGovernorsManager(who)) revert RequiresGovernorsManager(who);\\n    _;\\n  }\\n\\n  modifier onlyValidGovernor(address who) {\\n    if (!isValidGovernor(who)) revert RequiresValidGovernor(who);\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0xd1f8fc31da0062248ab8f238b67e499ee0004232415aceaa8f4f4600fee16706\",\"license\":\"MIT\"},\"contracts/common/AHasMembers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport \\\"../lib/LibAddressSet.sol\\\";\\nimport \\\"../lib/LibPaginate.sol\\\";\\nimport \\\"../interfaces/ICustomErrors.sol\\\";\\nimport \\\"./lib/LibHasMembers.sol\\\";\\n\\n/**\\n * @title The Members behaviour abstract contract.\\n * @notice The Fast Members abstract contract is in charge of keeping track of automaton accounts.\\n */\\nabstract contract AHasMembers {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  /// Errors.\\n\\n  /// @notice Happens when a function is called by an address that is not a members manager.\\n  error RequiresMembersManager(address who);\\n  /// @notice Happens when an address is used as a member but is not valid.\\n  error RequiresValidMember(address who);\\n\\n  /// Events.\\n\\n  /**\\n   * @notice Emited when a member is added to the implementing contract.\\n   * @param member is the address of the added member.\\n   */\\n  event MemberAdded(address indexed member);\\n  /**\\n   * @notice Emited when a member is removed to the implementing contract.\\n   * @param member is the address of the removed member.\\n   */\\n  event MemberRemoved(address indexed member);\\n\\n  /**\\n   * @notice Default implementation - points to `msg.sender`.\\n   * @dev May be overriden by the inheriting contract.\\n   */\\n  function _msgSender() internal view virtual returns (address) {\\n    return msg.sender;\\n  }\\n\\n  /**\\n   * @notice Checks whether the given address is a members manager or not.\\n   * @dev Must be implemented by the inheriting contract.\\n   * @param who is the address to test.\\n   */\\n  function isMembersManager(address who) internal view virtual returns (bool);\\n\\n  /**\\n   * @notice Checks whether the given address can be added as a member or not.\\n   * @dev Must be implemented by the inheriting contract.\\n   * @param who is the address to test.\\n   */\\n  function isValidMember(address who) internal view virtual returns (bool);\\n\\n  /**\\n   * @notice This callback is called when a member is added to the contract.\\n   * @dev May be overriden by the inheriting contract.\\n   * @param member is the address which was added.\\n   */\\n  function onMemberAdded(address member) internal virtual {}\\n\\n  /**\\n   * @notice This callback is called when a member is removed to the contract.\\n   * @dev May be overriden by the inheriting contract.\\n   * @param member is the address which was removed.\\n   */\\n  function onMemberRemoved(address member) internal virtual {}\\n\\n  // Members management.\\n\\n  /**\\n   * @notice Queries whether a given address is a member or not.\\n   * @param who is the address to test.\\n   * @return A `bool` equal to `true` when `candidate` is a member.\\n   */\\n  function isMember(address who) external view returns (bool) {\\n    return LibHasMembers.data().memberSet.contains(who);\\n  }\\n\\n  /**\\n   * @notice Queries the number of members.\\n   * @return An `uint256`.\\n   */\\n  function memberCount() external view returns (uint256) {\\n    return LibHasMembers.data().memberSet.values.length;\\n  }\\n\\n  /**\\n   * @notice Queries pages of members based on a start index and a page size.\\n   * @param index is the offset at which the pagination operation should start.\\n   * @param perPage is how many items should be returned.\\n   * @return A `(address[], uint256)` tuple, which first item is the list of addresses and the second item a cursor to the next page.\\n   */\\n  function paginateMembers(uint256 index, uint256 perPage) external view returns (address[] memory, uint256) {\\n    return LibPaginate.addresses(LibHasMembers.data().memberSet.values, index, perPage);\\n  }\\n\\n  /**\\n   * @notice Adds a member to the list of known members.\\n   * @param who is the address to be added.\\n   */\\n  function addMember(address who) external onlyMemberManager(_msgSender()) onlyValidMember(who) {\\n    // Add the member.\\n    LibHasMembers.data().memberSet.add(who, false);\\n    // Notify via callback.\\n    onMemberAdded(who);\\n    // Emit!\\n    emit MemberAdded(who);\\n  }\\n\\n  /**\\n   * @notice Removes a member from this contract.\\n   * @param member The address of the member to be removed.\\n   * @notice Requires that the caller is a member of this Issuer.\\n   * @notice Emits a `AHasMembers.MemberRemoved` event.\\n   */\\n  function removeMember(address member) external onlyMemberManager(_msgSender()) {\\n    // Notify via callback.\\n    onMemberRemoved(member);\\n    // Remove member.\\n    LibHasMembers.data().memberSet.remove(member, false);\\n    // Emit!\\n    emit MemberRemoved(member);\\n  }\\n\\n  /// Modifiers.\\n\\n  modifier onlyMemberManager(address who) {\\n    if (!isMembersManager(who)) revert RequiresMembersManager(who);\\n    _;\\n  }\\n\\n  modifier onlyValidMember(address who) {\\n    if (!isValidMember(who)) revert RequiresValidMember(who);\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x92011882d076ba62aac90c181c8f374566ca5c683441570a7239fd89851e97ff\",\"license\":\"MIT\"},\"contracts/common/lib/LibHasAutomatons.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport \\\"../../lib/LibAddressSet.sol\\\";\\n\\nlibrary LibHasAutomatons {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is `keccak256('HasAutomatons.storage.Main')`.\\n  bytes32 internal constant STORAGE_SLOT = 0x3dfe1f2f995ddddfe9572dcdd01e4fb472ed2fb10a125c3b0156e94d073b9183;\\n\\n  struct Data {\\n    /// @notice The latest intializer version that was called.\\n    uint16 version;\\n    /// @notice This is where we hold our automatons data.\\n    LibAddressSet.Data automatonSet;\\n    /// @notice This is where we store privileges for each of our automaton account.\\n    mapping(address => uint32) automatonPrivileges;\\n  }\\n\\n  function data() internal pure returns (Data storage s) {\\n    assembly {\\n      s.slot := STORAGE_SLOT\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x4fea753864796a68c0b1ef3137fcc43c3707a426e5f4ef37b35711ed77be34d3\",\"license\":\"MIT\"},\"contracts/common/lib/LibHasForwarder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nlibrary LibHasForwarder {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is `keccak256('HasForwarder.storage.Main')`.\\n  bytes32 internal constant STORAGE_SLOT = 0xa9930c2ffa1b605b0243ba36b3020146bcba5a29c05a711f5ca7c705a8e851ca;\\n\\n  struct Data {\\n    /// @notice The latest intializer version that was called.\\n    uint16 version;\\n    /// @notice This is where we store the trusted forwarder address.\\n    address forwarderAddress;\\n  }\\n\\n  function data() internal pure returns (Data storage s) {\\n    assembly {\\n      s.slot := STORAGE_SLOT\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x41d08f6cc69c5133d4b853803fab0c4b05f1f0d7c31331c4aa5b590b8dac0c9b\",\"license\":\"MIT\"},\"contracts/common/lib/LibHasGovernors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport \\\"../../lib/LibAddressSet.sol\\\";\\n\\nlibrary LibHasGovernors {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is `keccak256('HasGovernors.storage.Main')`.\\n  bytes32 internal constant STORAGE_SLOT = 0xdac4df64cf6992e5f0fa766abc48a6698b638db4d8eeee68133c41fdd4862975;\\n\\n  struct Data {\\n    /// @notice The latest intializer version that was called.\\n    uint16 version;\\n    /// @notice This is where we hold our automatons data.\\n    LibAddressSet.Data governorSet;\\n  }\\n\\n  function data() internal pure returns (Data storage s) {\\n    assembly {\\n      s.slot := STORAGE_SLOT\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xd9411857bd650e960901d07d793d9852fb1a4ee0a13007597f234138333c9d88\",\"license\":\"MIT\"},\"contracts/common/lib/LibHasMembers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport \\\"../../lib/LibAddressSet.sol\\\";\\n\\nlibrary LibHasMembers {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is `keccak256('HasMembers.storage.Main')`.\\n  bytes32 internal constant STORAGE_SLOT = 0xd56529bfa3ed57257eed4751494e1d0c0f212cfe38768380e006e3bee06ffb91;\\n\\n  struct Data {\\n    /// @notice The latest intializer version that was called.\\n    uint16 version;\\n    /// @notice This is where we hold our automatons data.\\n    LibAddressSet.Data memberSet;\\n  }\\n\\n  function data() internal pure returns (Data storage s) {\\n    assembly {\\n      s.slot := STORAGE_SLOT\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x03ea8d9c47249e9456deba85130e859afd6eba800e330527bcb9bc3438adb6a4\",\"license\":\"MIT\"},\"contracts/fast/Crowdfund.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport \\\"../lib/LibAddressSet.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../common/AHasMembers.sol\\\";\\nimport \\\"../common/AHasGovernors.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\n/**\\n * @title The `Crowdfund` FAST contract.\\n * @notice This contract is used to manage a crowdfunding campaign.\\n */\\ncontract Crowdfund {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  /// @notice Happens when a function requires an unmet phase.\\n  error InvalidPhase();\\n  /// @notice Happens when a duplicate entry is found.\\n  error DuplicateEntry();\\n  /// @notice Happens when inconsistent parametters are detected.\\n  error InconsistentParameter(string param);\\n  /// @notice Happens when an address is not a crowdfund pledger.\\n  error UnknownPledger(address who);\\n  /// @notice Happens when a call to the ERC20 token contract fails.\\n  error TokenContractError();\\n  /// @notice Happens when there are insufficient funds somewhere.\\n  error InsufficientFunds(uint256 amount);\\n\\n  /// @notice Happens when an address is not an issuer member.\\n  error RequiresIssuerMemberCaller();\\n  /// @notice Happens when an address is not a FAST member.\\n  error RequiresFastMemberCaller();\\n  /// @notice Happens when a parameter has to be a FAST member.\\n  error RequiresFastMembership(address who);\\n  /// @notice Happens when a parameter has to be a FAST governor.\\n  error RequiresFastGovernorship(address who);\\n\\n  /**\\n   * @notice Emited whenever the internal phase of this crowdfund changes.\\n   * @param phase The new phase of this contract.\\n   */\\n  event Advance(Phase phase);\\n\\n  /**\\n   * @notice Emited whenever a plege is made.\\n   * @param pledger The address of the pledger.\\n   * @param amount The amount of tokens pledged.\\n   */\\n  event Pledge(address indexed pledger, uint256 amount);\\n\\n  /**\\n   * @notice Emited when the crowdfunding is terminated.\\n   * @param success Whether the crowdfunding was successful or not.\\n   */\\n  event Terminated(bool indexed success);\\n\\n  /// @notice The different phases of the crowdfund.\\n  enum Phase {\\n    Setup,\\n    Funding,\\n    Success,\\n    Failure\\n  }\\n\\n  /// @notice Parameters to be passed to this contract's constructor.\\n  struct Params {\\n    /// @notice Who initially deployed this contract.\\n    address owner;\\n    /// @notice The issuer contract address.\\n    address issuer;\\n    /// @notice The FAST contract that this crowdfund is locked onto.\\n    address fast;\\n    /// @notice The beneficiary of the crowdfund.\\n    address beneficiary;\\n    /// @notice The fee expressed in basis points - eg ten thousandths.\\n    uint32 basisPointsFee;\\n    /// @notice The token contract address.\\n    IERC20 token;\\n    /// @notice An arbitrary reference string to keep track of.\\n    string ref;\\n  }\\n\\n  /// @notice A version identifier for us to track what's deployed.\\n  uint16 public constant VERSION = 2;\\n\\n  /// @notice The initial params, as passed to the contract's constructor.\\n  Params private params;\\n  /// @notice The phase at which the crowdfunding is at.\\n  Phase public phase;\\n  /// @notice When was the distribution created.\\n  uint256 public creationBlock;\\n  /// @notice How much was collected so far.\\n  uint256 public collected;\\n\\n  /// @notice The set of addresses that have pledged to this crowdfund.\\n  LibAddressSet.Data internal pledgerSet;\\n  /// @notice The mapping of pledgers to their pledged amounts.\\n  mapping(address => uint256) public pledges;\\n  /// @notice Mapping of pledgers to whether they have been refunded or not.\\n  mapping(address => bool) public refunded;\\n\\n  /**\\n   * @notice The constructor for this contract.\\n   * Note that the constructor places the contract into the setup phase.\\n   * @param p The parameters to be passed to this contract's constructor.\\n   */\\n  constructor(Params memory p) {\\n    // Store parameters.\\n    params = p;\\n    // Check that the owner is a FAST governor.\\n    if (!isFastGovernor(params.owner)) revert RequiresFastGovernorship(params.owner);\\n    // Check that the beneficiary is a member of the FAST contract.\\n    else if (!isFastMember(params.beneficiary)) revert RequiresFastMembership(params.beneficiary);\\n    // Invalid fee - superior than 100%.\\n    else if (params.basisPointsFee > 10_000) revert InconsistentParameter(\\\"basisPointsFee\\\");\\n    // Keep creation block handy.\\n    creationBlock = block.number;\\n  }\\n\\n  /// @dev Given a total and a fee in basis points, returns the fee amount rounded up.\\n  function feeAmount() public view returns (uint256) {\\n    return Math.mulDiv(collected, params.basisPointsFee, 10_000, Math.Rounding.Up);\\n  }\\n\\n  /**\\n   * @notice Advances the campaign to the funding phase.\\n   * Note that this method is only available during the setup phase.\\n   */\\n  function advanceToFunding(uint32 basisPointsFee) external onlyDuring(Phase.Setup) onlyIssuerMember {\\n    // Make sure the fee doesn't exceed a hundred percent.\\n    if (params.basisPointsFee != basisPointsFee) {\\n      // Invalid fee.\\n      if (basisPointsFee > 10_000) revert InconsistentParameter(\\\"basisPointsFee\\\");\\n      // Set new overriden fee.\\n      params.basisPointsFee = basisPointsFee;\\n    }\\n    emit Advance(phase = Phase.Funding);\\n  }\\n\\n  /**\\n   * @notice Allows a pledger to pledge tokens to this crowdfund.\\n   * Note that this method is only available during the funding phase.\\n   * @param amount The amount of tokens to pledge.\\n   */\\n  function pledge(uint256 amount) public onlyDuring(Phase.Funding) onlyFastMember {\\n    // Make sure the amount is non-zero.\\n    if (amount == 0) revert InconsistentParameter(\\\"amount\\\");\\n    // Make sure that the message sender gave us allowance for at least this amount.\\n    uint256 allowance = params.token.allowance(msg.sender, address(this));\\n    if (allowance < amount) revert InsufficientFunds(amount - allowance);\\n    // Keep track of the pledger - don't throw if already present.\\n    pledgerSet.add(msg.sender, true);\\n    // Add the pledged amount to the existing pledge.\\n    pledges[msg.sender] += amount;\\n    // Update the collected amount.\\n    collected += amount;\\n    // Transfer the tokens to this contract.\\n    if (!params.token.transferFrom(msg.sender, address(this), amount)) revert TokenContractError();\\n    // Emit!\\n    emit Pledge(msg.sender, amount);\\n  }\\n\\n  /**\\n   * @notice Queries the number of members.\\n   * @return An `uint256`.\\n   */\\n  function pledgerCount() public view returns (uint256) {\\n    return pledgerSet.values.length;\\n  }\\n\\n  /**\\n   * @notice Queries pages of pledgers based on a start index and a page size.\\n   * @param index is the offset at which the pagination operation should start.\\n   * @param perPage is how many items should be returned.\\n   * @return A `(address[], uint256)` tuple, which first item is the list of addresses and the second item a cursor to the next page.\\n   */\\n  function paginatePledgers(uint256 index, uint256 perPage) external view returns (address[] memory, uint256) {\\n    return LibPaginate.addresses(pledgerSet.values, index, perPage);\\n  }\\n\\n  /**\\n   * @notice Allows an issuer member to terminate the crowdfunding given a success flag.\\n   * Note that this method is available during any phase and can be used as a panic\\n   * button to terminate the crowdfunding prematurely.\\n   * @param success Whether the crowdfunding was successful or not.\\n   */\\n  function terminate(bool success) public onlyIssuerMember {\\n    // If the crowdfunding was successful...\\n    if (success) {\\n      // Transfer the fee to the issuer contract if there is one.\\n      uint256 finalFee = feeAmount();\\n      if (finalFee > 0)\\n        if (!params.token.transfer(params.issuer, finalFee)) revert TokenContractError();\\n      // Transfer the payout to the beneficiary.\\n      uint256 payout = collected - finalFee;\\n      // If there's a payout for the beneficiary, transfer it.\\n      if (payout > 0)\\n        if (!isFastMember(params.beneficiary))\\n          // Make sure that the beneficiary is **still** a member of the FAST contract.\\n          revert RequiresFastMembership(params.beneficiary);\\n        // Attempt to transfer to the beneficiary.\\n        else if (!params.token.transfer(params.beneficiary, payout)) revert TokenContractError();\\n    }\\n    // Advance to next phase.\\n    emit Advance(phase = success ? Phase.Success : Phase.Failure);\\n  }\\n\\n  /**\\n   * @notice Allows a pledger to be refunded if the crowdfunding failed.\\n   * Note that this method is only available during the failure phase.\\n   * @param pledger The address of the pledger to refund.\\n   */\\n  function refund(address pledger) public onlyDuring(Phase.Failure) {\\n    // Make sure the pledger is in the set.\\n    if (!pledgerSet.contains(pledger)) revert UnknownPledger(pledger);\\n    // Pledger has already been refunded...\\n    else if (refunded[pledger]) revert DuplicateEntry();\\n    // Track that the pledger has been refunded.\\n    refunded[pledger] = true;\\n    // Transfer the tokens to the pledger.\\n    if (!params.token.transfer(pledger, pledges[pledger])) revert TokenContractError();\\n  }\\n\\n  /// Frontend helper functions.\\n\\n  /**\\n   * @dev Returns the parameter struct used to construct this contract.\\n   * @return The parameter struct.\\n   */\\n  function paramsStruct() external view returns (Params memory) {\\n    return params;\\n  }\\n\\n  /**\\n   * @notice Crowdfund details.\\n   * @dev This struct shouldn't be used in internal storage.\\n   */\\n  struct Details {\\n    address addr;\\n    uint16 VERSION;\\n    Crowdfund.Params params;\\n    Crowdfund.Phase phase;\\n    uint256 creationBlock;\\n    uint256 collected;\\n    uint256 feeAmount;\\n    uint256 pledgerCount;\\n  }\\n\\n  /**\\n   * @notice Gets detailed crowdfund information.\\n   * @return See: `Details`.\\n   */\\n  function details() public view returns (Details memory) {\\n    return\\n      Details({\\n        addr: address(this),\\n        VERSION: VERSION,\\n        params: params,\\n        phase: phase,\\n        creationBlock: creationBlock,\\n        collected: collected,\\n        feeAmount: feeAmount(),\\n        pledgerCount: pledgerCount()\\n      });\\n  }\\n\\n  /// Modifiers and ACL functions.\\n\\n  /**\\n   * @dev Checks whether the given address is a member of the FAST contract.\\n   * @param who The address to check.\\n   * @return A `bool` indicating whether the address is a member of the FAST contract.\\n   */\\n  function isFastMember(address who) internal view returns (bool) {\\n    return AHasMembers(params.fast).isMember(who);\\n  }\\n\\n  function isFastGovernor(address who) internal view returns (bool) {\\n    return AHasGovernors(params.fast).isGovernor(who);\\n  }\\n\\n  modifier onlyDuring(Phase _phase) {\\n    if (_phase != phase) revert InvalidPhase();\\n    _;\\n  }\\n\\n  modifier onlyIssuerMember() {\\n    if (!AHasMembers(params.issuer).isMember(msg.sender)) revert RequiresIssuerMemberCaller();\\n    _;\\n  }\\n\\n  modifier onlyFastMember() {\\n    if (!isFastMember(msg.sender)) revert RequiresFastMemberCaller();\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0xba08fe2063eca8944880c6539d04da19bfa0d68600e1b40ad807a024eccca8a6\",\"license\":\"MIT\"},\"contracts/fast/Distribution.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport \\\"../lib/LibAddressSet.sol\\\";\\nimport \\\"../lib/LibPaginate.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../common/AHasMembers.sol\\\";\\nimport \\\"../common/AHasAutomatons.sol\\\";\\nimport \\\"./FastAutomatonsFacet.sol\\\";\\n\\n/**\\n * @title The `Distribution` FAST contract.\\n * @notice This contract allows for dividends or proceeds to be distributted amongst\\n * a list of beneficiaries. It has a lifecycle that can be described based on the\\n * following steps (or phases):\\n * - Funding, during which the sum to be distributed has to be credited to this contract.\\n * - FeeSetup, during which the oracle will define the fee to be paid upon distribution.\\n * - BeneficiariesSetup, during which the oracle can setup the beneficiaries.\\n * - Withdrawal, during which each beneficiary can withdraw their proceeds.\\n * - Terminated, during which nothing is possible.\\n */\\ncontract Distribution {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  /// @notice Happens when a function requires an unmet phase.\\n  error InvalidPhase();\\n  /// @notice Happens when a duplicate entry is found.\\n  error DuplicateEntry();\\n  /// @notice Happens when inconsistent parametters are detected.\\n  error InconsistentParameter(string param);\\n  /// @notice Happens when a call to the ERC20 token contract fails.\\n  error TokenContractError();\\n  /// @notice Happens when there are insufficient funds somewhere.\\n  error InsufficientFunds(uint256 amount);\\n  /// @notice Happens when the distribution has been overfunded.\\n  error Overfunded(uint256 amount);\\n  /// @notice Happens when a beneficiary is not found.\\n  error UnknownBeneficiary(address who);\\n\\n  /// @notice Happens when a function must be called by the FAST contract.\\n  error RequiresFastCaller();\\n  /// @notice Happens when an address is not crowdfund manager.\\n  error RequiresManagerCaller();\\n  /// @notice Happens when a parameter has to be a FAST member.\\n  error RequiresFastMembership(address who);\\n\\n  /// @notice The possible phases in which the contract is in.\\n  enum Phase {\\n    Funding,\\n    FeeSetup,\\n    BeneficiariesSetup,\\n    Withdrawal,\\n    Terminated\\n  }\\n\\n  /**\\n   * @notice Emited whenever the internal phase of this distribution changes.\\n   * @param phase The new phase of this contract.\\n   */\\n  event Advance(Phase phase);\\n  /**\\n   * @notice Emited whenever a beneficiary is added to the distribution list.\\n   * @param beneficiary is the address of the beneficiary who was added.\\n   * @param amount is the amount in native target token that is owed to the beneficiary.\\n   */\\n  event BeneficiaryAdded(address indexed beneficiary, uint256 indexed amount);\\n  /**\\n   * @notice Emited whenever a beneficiary is removed from the distribution list.\\n   * @param beneficiary is the address of the beneficiary who was removed.\\n   */\\n  event BeneficiaryRemoved(address indexed beneficiary);\\n  /**\\n   * @notice Emited whenever a beneficiary withdraws their owings.\\n   * @param caller is the address who ordered the withdrawal.\\n   * @param beneficiary is the address of the beneficiary who performed the withdrawal.\\n   * @param amount is the amount that was withdrawn.\\n   */\\n  event Withdrawal(address indexed caller, address indexed beneficiary, uint256 amount);\\n\\n  /// @notice Parameters to be passed to this contract's constructor.\\n  struct Params {\\n    /// @notice The distributor of the distribution - eg the address who ordered its deployment.\\n    address distributor;\\n    /// @notice The Issuer contract address.\\n    address issuer;\\n    /// @notice To which FAST this Distribution belongs\\n    address fast;\\n    /// @notice The target ERC20 address to be distributed to the beneficiaries.\\n    IERC20 token;\\n    /// @notice Block latching.\\n    uint256 blockLatch;\\n    /// @notice How much is meant to be distributed.\\n    uint256 total;\\n    /// @notice An arbitrary reference string.\\n    string ref;\\n  }\\n\\n  /// @notice A version identifier for us to track what's deployed.\\n  uint16 public constant VERSION = 4;\\n\\n  /// @notice The initial params, as passed to the contract's constructor.\\n  Params private params;\\n  /// @notice The phase at which the distribution is at.\\n  Phase public phase = Phase.Funding;\\n  /// @notice When was the distribution created.\\n  uint256 public creationBlock;\\n  /// @notice How much the fee that will be distributed to `issuer` is.\\n  uint256 public fee;\\n  /// @notice How much is left for distribution.\\n  uint256 public available;\\n\\n  /// @notice The list of beneficiaries known to the system.\\n  LibAddressSet.Data internal beneficiaries;\\n  /// @notice How much was set asside for a particular beneficiary.\\n  mapping(address => uint256) public owings;\\n  /// @notice Whether or not a benificiary has withdrawn yet.\\n  mapping(address => bool) public withdrawn;\\n\\n  /**\\n   * @notice Constructs a new `Distribution` contracts.\\n   * @param p is a `Params` structure.\\n   */\\n  constructor(Params memory p) {\\n    // If the distribution is latched in the future, throw.\\n    if (p.blockLatch >= block.number) revert InconsistentParameter(\\\"blockLatch\\\");\\n    // Store all parameters.\\n    params = p;\\n    available = p.total;\\n    creationBlock = block.number;\\n  }\\n\\n  function advanceToFeeSetup() public onlyDuring(Phase.Funding) onlyFastCaller {\\n    // Make sure that the current distribution has exactly the required amount locked.\\n    uint256 balance = params.token.balanceOf(address(this));\\n    if (balance != params.total) revert InconsistentParameter(\\\"balance\\\");\\n    // Move to next phase.\\n    emit Advance(phase = Phase.FeeSetup);\\n  }\\n\\n  /**\\n   * @notice Sets the fee to be taken upon distribution. Only available during the\\n   * `Phase.FeeSetup` phase, throws otherwise. This method automatically advances the\\n   * phase to `Phase.BeneficiariesSetup`, so it can only be called once.\\n   * Note that only a manager (issuer or automaton with the correct privileges) can\\n   * call this method.\\n   * @param _fee is the amount that the `issuer` will receive.\\n   */\\n  function advanceToBeneficiariesSetup(uint256 _fee) external onlyDuring(Phase.FeeSetup) onlyManager {\\n    fee = _fee;\\n    available -= fee;\\n    // Move to next phase.\\n    emit Advance(phase = Phase.BeneficiariesSetup);\\n  }\\n\\n  /**\\n   * @notice Advances the distribution to the `Phase.Withdrawal` phase.\\n   * The distribution must be in the `Phase.BeneficiariesSetup` phase.\\n   */\\n  function advanceToWithdrawal() public onlyDuring(Phase.BeneficiariesSetup) onlyManager {\\n    // If the distribution covers more than the sum of all proceeds, we want\\n    // to prevent the distribution from advancing to the withdrawal phase.\\n    if (available > 0) revert Overfunded(available);\\n    // Transfer the fee to the issuer contract.\\n    if (!params.token.transfer(params.issuer, fee)) revert TokenContractError();\\n    // Move to next phase.\\n    emit Advance(phase = Phase.Withdrawal);\\n  }\\n\\n  /**\\n   * @notice Adds beneficiaries and amounts to the distribution list. Both `_beneficiaries`\\n   * and `_amounts` arrays must be of the same size, or the method will revert.\\n   * This method is only available during the `Phase.BeneficiariesSetup` phase.\\n   * During execution, this method will make sure that the cumulated amounts for all\\n   * beneficiaries doesn't exceed the `total` amount available for distribution, or it\\n   * will simply throw.\\n   * Note that adding the same beneficiary twice will throw.\\n   * Note that only a manager (issuer or automaton with the correct privileges) can\\n   * call this method.\\n   * @param _beneficiaries is the list of beneficiaries to add.\\n   * @param _amounts is the list of amounts respective to each beneficiary.\\n   */\\n  function addBeneficiaries(\\n    address[] calldata _beneficiaries,\\n    uint256[] calldata _amounts\\n  ) public onlyDuring(Phase.BeneficiariesSetup) onlyManager {\\n    // Beneficiaries and amount sizes must match.\\n    if (_beneficiaries.length != _amounts.length) revert InconsistentParameter(\\\"lengths\\\");\\n\\n    // We will count how much is needed for all these beneficiaries.\\n    uint256 needed = 0;\\n    // For each of the passed beneficiaries...\\n    for (uint256 i = 0; i < _beneficiaries.length; ) {\\n      // Memoize a few variables...\\n      address beneficiary = _beneficiaries[i];\\n      uint256 amount = _amounts[i];\\n      // Make sure the beneficiary is a member of the FAST.\\n      if (!AHasMembers(params.fast).isMember(beneficiary)) revert RequiresFastMembership(beneficiary);\\n\\n      // Add the beneficiary to our set.\\n      beneficiaries.add(beneficiary, false);\\n      // Keep track of the amount this beneficiary is entitled to.\\n      owings[beneficiary] = amount;\\n      // Accumulate how much is needed for these beneficiaries.\\n      needed += amount;\\n      // Emit!\\n      emit BeneficiaryAdded(beneficiary, amount);\\n      // Next iteration.\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n\\n    // Make sure that there's enough to pay everyone.\\n    if (available < needed) revert InsufficientFunds(needed - available);\\n    // Decrease the amount of available funds.\\n    unchecked {\\n      available -= needed;\\n    }\\n  }\\n\\n  /**\\n   * @notice Removes a list of beneficiaries from the distribution list.\\n   * Note that removing a non-existent beneficiary will simply throw.\\n   * During execution, this method will increase the amount available for\\n   * distribution automatically.\\n   * Note that only a manager (issuer or automaton with the correct privileges) can\\n   * call this method.\\n   * @param _beneficiaries is the list of addresses to remove.\\n   */\\n  function removeBeneficiaries(address[] calldata _beneficiaries) external onlyDuring(Phase.BeneficiariesSetup) onlyManager {\\n    // Remove all specified beneficiaries.\\n    for (uint256 i = 0; i < _beneficiaries.length; ) {\\n      address beneficiary = _beneficiaries[i];\\n      // Remove the beneficiary from our list.\\n      beneficiaries.remove(beneficiary, false);\\n      // Increase the amount available for distribution, as it won't go to this beneficiary.\\n      available += owings[beneficiary];\\n      // Set the beneficiary's balance to zero.\\n      owings[beneficiary] = 0;\\n      // Emit!\\n      emit BeneficiaryRemoved(beneficiary);\\n      // Next iteration.\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n\\n  /**\\n   *\\n   * @notice Returns the number of beneficiaries added so far.\\n   * @return The count.\\n   */\\n  function beneficiaryCount() public view returns (uint256) {\\n    return beneficiaries.values.length;\\n  }\\n\\n  /**\\n   * @notice Queries pages of beneficiaries based on a start index and a page size.\\n   * Note that it is possible to query owings for each of these beneficiaries by\\n   * utilizing the `owings` and `withdrawn` public function.\\n   * @param index is the offset at which the pagination operation should start.\\n   * @param perPage is how many items should be returned.\\n   * @return A `(address[], uint256)` tuple, which first item is the list of addresses and the second item a cursor to the next page.\\n   */\\n  function paginateBeneficiaries(uint256 index, uint256 perPage) external view returns (address[] memory, uint256) {\\n    return LibPaginate.addresses(beneficiaries.values, index, perPage);\\n  }\\n\\n  /**\\n   * @notice This function allows any beneficiary to withdraw what they are owed. This\\n   * method can only be called during the `Phase.Withdrawal` phase.\\n   * Note that this function is protected from reentrancy as it operates on the `token`\\n   * methods.\\n   */\\n  function withdraw(address beneficiary) public onlyDuring(Phase.Withdrawal) {\\n    if (!beneficiaries.contains(beneficiary)) revert UnknownBeneficiary(beneficiary);\\n    else if (withdrawn[beneficiary]) revert DuplicateEntry();\\n    // Memoize a few variables.\\n    uint256 amount = owings[beneficiary];\\n    // Make sure they can't do it again later... It is important\\n    // to do this before any call to `token` to prevent reentrancy.\\n    withdrawn[beneficiary] = true;\\n    // Transfer to the beneficiary all of their ownings.\\n    if (!params.token.transfer(beneficiary, amount)) revert TokenContractError();\\n    // Emit!\\n    emit Withdrawal(msg.sender, beneficiary, amount);\\n  }\\n\\n  /**\\n   * @notice A panic function that can only be called by the distribution manager\\n   * (either an issuer member or an automaton with the right privileges).\\n   * Upon calling this method, the contract will simply send back any funds still\\n   * available to it and set its internal state to a termination one.\\n   * Note that since this method calls the `token` contract, it **must be\\n   * protected against reentrancy**.\\n   */\\n  function terminate() public onlyManager exceptDuring(Phase.Terminated) {\\n    // Reset internal variables so that it's clear that the contract is terminated.\\n    // It is important to do this prior to any call to `token` methods to prevent\\n    // re-entrancy attacks.\\n    emit Advance(phase = Phase.Terminated);\\n    available = 0;\\n    // Move all funds to the distributor account.\\n    params.token.transfer(params.distributor, params.token.balanceOf(address(this)));\\n  }\\n\\n  /// Frontend helpers.\\n\\n  /**\\n   * @dev Returns the parameter struct used to construct this contract.\\n   * @return The parameter struct.\\n   */\\n  function paramsStruct() external view returns (Params memory) {\\n    return params;\\n  }\\n\\n  /**\\n   * @notice Distribution details.\\n   * @dev This struct shouldn't be used in internal storage.\\n   */\\n  struct Details {\\n    address addr;\\n    uint16 VERSION;\\n    Distribution.Params params;\\n    Distribution.Phase phase;\\n    uint256 creationBlock;\\n    uint256 fee;\\n    uint256 available;\\n    uint256 beneficiaryCount;\\n  }\\n\\n  /**\\n   * @notice Gets detailed distribution information.\\n   * @return See: `Details`.\\n   */\\n  function details() public view returns (Details memory) {\\n    return\\n      Details({\\n        addr: address(this),\\n        VERSION: VERSION,\\n        params: params,\\n        phase: phase,\\n        creationBlock: creationBlock,\\n        fee: fee,\\n        available: available,\\n        beneficiaryCount: beneficiaryCount()\\n      });\\n  }\\n\\n  /// Modifiers.\\n\\n  modifier onlyDuring(Phase _phase) {\\n    if (_phase != phase) revert InvalidPhase();\\n    _;\\n  }\\n\\n  modifier exceptDuring(Phase _phase) {\\n    if (_phase == phase) revert InvalidPhase();\\n    _;\\n  }\\n\\n  modifier onlyFastCaller() {\\n    if (msg.sender != params.fast) revert RequiresFastCaller();\\n    _;\\n  }\\n\\n  modifier onlyManager() {\\n    if (\\n      !AHasMembers(params.issuer).isMember(msg.sender) &&\\n      !AHasAutomatons(params.fast).automatonCan(msg.sender, FAST_PRIVILEGE_MANAGE_DISTRIBUTIONS)\\n    ) revert RequiresManagerCaller();\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x0bcaee03eb96c223e2b978dd301308315c8fda5e65973288a22b7809ea288f1b\",\"license\":\"MIT\"},\"contracts/fast/FastAutomatonsFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport \\\"./lib/AFastFacet.sol\\\";\\nimport \\\"../common/AHasAutomatons.sol\\\";\\n\\n// Privileges bits.\\nuint32 constant FAST_PRIVILEGE_MANAGE_MEMBERS = 1;\\nuint32 constant FAST_PRIVILEGE_MANAGE_DISTRIBUTIONS = 2;\\n\\n/**\\n * @title The Fast Smart Contract.\\n * @notice The Fast Automatons facet is in charge of keeping track of automaton accounts.\\n */\\ncontract FastAutomatonsFacet is AFastFacet, AHasAutomatons {\\n  /// Automatons management.\\n\\n  function isAutomatonsManager(address who) internal view override(AHasAutomatons) returns (bool) {\\n    return _isIssuerMember(who);\\n  }\\n}\\n\",\"keccak256\":\"0x59dfae35415bbcba6ab9a9f9ba70ef426c08d3685428c9d9070129c5412a2d51\",\"license\":\"MIT\"},\"contracts/fast/FastForwardableFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport \\\"../common/AHasForwarder.sol\\\";\\nimport \\\"./lib/AFastFacet.sol\\\";\\n\\n/**\\n * @title The Fast forwardable contract.\\n * @notice The Fast Forwardable facet is in charge of \\\"gasless transactions\\\".\\n */\\ncontract FastForwardableFacet is AFastFacet, AHasForwarder {\\n  /// AHasForwarder implementation.\\n\\n  // For now the forwarder manager is an issuer.\\n  function isValidForwarderManager(address who) internal view override(AHasForwarder) returns (bool) {\\n    return _isIssuerMember(who);\\n  }\\n}\\n\",\"keccak256\":\"0xb6fa7492088962c4a64c517f79a046749376b1158f65ae01b912264f0a659ce6\",\"license\":\"MIT\"},\"contracts/fast/lib/AFastFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport \\\"../../lib/LibHelpers.sol\\\";\\nimport \\\"../../lib/LibAddressSet.sol\\\";\\nimport \\\"../../common/AHasGovernors.sol\\\";\\nimport \\\"../../common/AHasMembers.sol\\\";\\nimport \\\"../../common/AHasAutomatons.sol\\\";\\nimport \\\"../../interfaces/IHasActiveMembers.sol\\\";\\nimport \\\"../lib/LibFast.sol\\\";\\nimport \\\"./IFastEvents.sol\\\";\\n\\n/**\\n * @title Abstract FAST helper contract.\\n * @notice This abstract contract encapsulates modifiers allowing inheriting facets to guard against\\n * certain permissions.\\n */\\nabstract contract AFastFacet is IFastEvents {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  /// Internal ACL functions.\\n\\n  function _isMarketplaceMember(address who) internal view returns (bool) {\\n    return AHasMembers(LibFast.data().marketplace).isMember(who);\\n  }\\n\\n  function _isMarketplaceActiveMember(address who) internal view returns (bool) {\\n    return IHasActiveMembers(LibFast.data().marketplace).isActiveMember(who);\\n  }\\n\\n  function _isIssuerMember(address who) internal view returns (bool) {\\n    return AHasMembers(LibFast.data().issuer).isMember(who);\\n  }\\n\\n  /// Modifiers.\\n\\n  /// @notice Ensures that a method can only be called by another facet of the same diamond.\\n  modifier onlyDiamondFacet() {\\n    if (!LibHelpers._isDiamondFacet(msg.sender)) revert ICustomErrors.InternalMethod();\\n    _;\\n  }\\n\\n  /// @notice Ensures that a method can only be called by the owner of this diamond.\\n  modifier onlyDiamondOwner() {\\n    if (!LibHelpers._isDiamondOwner(msg.sender)) revert ICustomErrors.RequiresDiamondOwnership(msg.sender);\\n    _;\\n  }\\n\\n  /// @notice Ensures that a method can only be called by the singleton deployer contract factory.\\n  modifier onlyDeployer() {\\n    if (!LibHelpers._isDeployer(msg.sender)) revert ICustomErrors.InternalMethod();\\n    _;\\n  }\\n\\n  /// @notice Ensures that a method can only be called by the issuer contract.\\n  modifier onlyIssuerContract() {\\n    if (msg.sender != LibFast.data().issuer) revert ICustomErrors.InternalMethod();\\n    _;\\n  }\\n\\n  /**\\n   * @notice Ensures that the given address is a member of the Marketplace.\\n   * @param who The address to check.\\n   */\\n  modifier onlyMarketplaceMember(address who) {\\n    if (!_isMarketplaceMember(who)) revert ICustomErrors.RequiresMarketplaceMembership(who);\\n    _;\\n  }\\n\\n  /**\\n   * @notice Ensures a who is an active member of the Marketplace.\\n   * @param who The address to check.\\n   */\\n  modifier onlyMarketplaceActiveMember(address who) {\\n    if (!_isMarketplaceActiveMember(who)) revert ICustomErrors.RequiresMarketplaceActiveMembership(who);\\n    _;\\n  }\\n\\n  /**\\n   * @notice Ensures that the message sender is a member of the Issuer.\\n   */\\n  modifier onlyIssuerMember() {\\n    if (!_isIssuerMember(msg.sender)) revert ICustomErrors.RequiresIssuerMembership(msg.sender);\\n    _;\\n  }\\n\\n  modifier onlyIssuerMemberOrIssuerContract() {\\n    if (!_isIssuerMember(msg.sender) && msg.sender != LibFast.data().issuer)\\n      revert ICustomErrors.RequiresIssuerMemberOrIssuerCaller();\\n    _;\\n  }\\n\\n  /**\\n   * @notice Ensures that the given address is a governor of the FAST.\\n   * @param who The address to check.\\n   */\\n  modifier onlyGovernor(address who) {\\n    if (!AHasGovernors(address(this)).isGovernor(who)) revert ICustomErrors.RequiresFastGovernorship(who);\\n    _;\\n  }\\n\\n  /**\\n   * @notice Ensures that the given address is a member of the FAST.\\n   * @param who The address to check.\\n   */\\n  modifier onlyMember(address who) {\\n    if (!AHasMembers(address(this)).isMember(who)) revert ICustomErrors.RequiresFastMembership(who);\\n    _;\\n  }\\n\\n  /**\\n   * @notice Ensures address `a` and `b` are different.\\n   * @param a Address a\\n   * @param b Address b\\n   */\\n  modifier differentAddresses(address a, address b) {\\n    if (a == b) revert ICustomErrors.RequiresDifferentSenderAndRecipient(a);\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x71ae529ee7eb8055921ecf3080045b5e6286b90b2809301da1938e250793ee7d\",\"license\":\"MIT\"},\"contracts/fast/lib/IFastEvents.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport \\\"../../fast/Distribution.sol\\\";\\nimport \\\"../../fast/Crowdfund.sol\\\";\\n\\n/**\\n * @title FAST events inventory.\\n * @notice An interface allowing to use events within the Diamond pattern without name colisions.\\n * @dev The idea is that as several facets can emit the same events, we don't want to have to re-declare\\n * the same event several time. This interface is a per-diamond central place for such event declaration.\\n */\\ninterface IFastEvents {\\n  /// Issuance related events.\\n\\n  /**\\n   * @notice Emited whenever an issuance happens in a FAST.\\n   * @param amount is the amount of tokens that have been minted.\\n   * @param ref is the reference associated with the minting operation.\\n   * @param who is the account from which the minting operation originated.\\n   */\\n  event Minted(uint256 indexed amount, string ref, address indexed who);\\n\\n  /**\\n   * @notice Emited whenever an burning happens in a FAST.\\n   * @param amount is the amount of tokens that have been burnt.\\n   * @param ref is the reference associated with the burning operation.\\n   * @param who is the account from which the burning operation originated.\\n   */\\n  event Burnt(uint256 indexed amount, string ref, address indexed who);\\n\\n  /// Transfer and ERC20 stuff.\\n\\n  /// @notice See `ERC20.Disapproval`.\\n  event Disapproval(address indexed owner, address indexed spender, uint256 value);\\n\\n  /**\\n   * @notice As we augmented the ERC20 standard with a few concepts, we emit our custom events\\n   * in addition to the ERC20 ones.\\n   * @param spender is the account who performed the transfer.\\n   * @param from is the account from which the tokens will be debited from.\\n   * @param to is the account to which the tokens will be credited to.\\n   * @param value is the amount of tokens transfered.\\n   * @param ref is the optional reference associated with the transfer.\\n   */\\n  event FastTransfer(address indexed spender, address indexed from, address indexed to, uint256 value, string ref);\\n\\n  /// Distribution related events.\\n\\n  event DistributionDeployed(Distribution indexed distribution);\\n  event DistributionRemoved(Distribution indexed distribution);\\n\\n  /// Crowdfund related events.\\n\\n  event CrowdfundDeployed(Crowdfund indexed crowdfund);\\n  event CrowdfundRemoved(Crowdfund indexed crowdfund);\\n  event CrowdfundDefaultBasisPointFeeSet(uint32 indexed basisPointFee);\\n\\n  /// General events.\\n\\n  /**\\n   * @notice This is an event that is fired whenever any of some of the FAST parameters\\n   * change, so that the frontend can react to it and refresh the general header\\n   * for that fast as well as the baseball cards in the FASTs list.\\n   * @param transfersDisabled marks whether or not transfers are disabled by an issuer member at FAST level.\\n   * @param memberCount is the number of members in the FAST.\\n   * @param governorCount is the number of governors in the FAST.\\n   * @param totalSupply is the amount of tokens in circulation in the FAST.\\n   * @param reserveBalance is the balance of the zero-address (aka reserve) for the FAST.\\n   */\\n  event DetailsChanged(\\n    bool transfersDisabled,\\n    uint32 crowdfundsDefaultBasisPointsFee,\\n    uint256 memberCount,\\n    uint256 governorCount,\\n    uint256 totalSupply,\\n    uint256 reserveBalance\\n  );\\n}\\n\",\"keccak256\":\"0x64ac3bc4aaa8ea06efef19407baed93a5e960c2b822e732517efc2c991e96795\",\"license\":\"MIT\"},\"contracts/fast/lib/LibFast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\n/**\\n * @notice Top-level shared functionality for FAST diamonds.\\n * @dev Note that if you feel like a method should be created inside this library, you might want to really consider\\n * whether or not it is the right place for it. Any facet using a method from internal libraries see their bytecode\\n * size increase, kind of defeating the benefits of using facets in the first place. So please keep it reasonable.\\n */\\nlibrary LibFast {\\n  /// @notice The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  /// @notice This is keccak256('Fast.storage'):\\n  bytes32 internal constant STORAGE_SLOT = 0x80c187ea6f955fd624c41fb7a18011cc87d98c6f4c06d897b59142f65707e705;\\n\\n  // Data structures.\\n\\n  /**\\n   * @notice The top-level data structure required for operating any given FAST diamond.\\n   * @dev The `version` field is used to ensure that storage is at a known version during upgrades.\\n   */\\n  struct Data {\\n    /// @notice The latest intializer version that was called.\\n    uint16 version;\\n    /// @notice The internal pointer to the Issuer contract.\\n    address issuer;\\n    /// @notice The internal pointer to the Marketplace contract.\\n    address marketplace;\\n    /// @notice We have to track whether the token facet provides continuous minting or fixed supply.\\n    bool hasFixedSupply;\\n    /// @notice Whether or not this FAST requires to be a member to hold tokens.\\n    bool isSemiPublic;\\n    /// @notice A flag which when toggled to `true` disables all transfers across this FAST.\\n    bool transfersDisabled;\\n    /// @notice To which FAST group this FAST belongs to, if any.\\n    string group;\\n  }\\n\\n  /**\\n   * @notice Returns the top-level storage for the calling FAST.\\n   * @return s a struct pointer for top-level FAST data storage.\\n   */\\n  function data() internal pure returns (Data storage s) {\\n    assembly {\\n      s.slot := STORAGE_SLOT\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x4d0e728e344cf6a93f7a75c2a19261dbae575878ac9830b496c9a225985f8de3\",\"license\":\"MIT\"},\"contracts/fast/lib/LibFastHistory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\n/**\\n * @notice This library centralises shared functionality between FAST diamonds facets that have to do with transfer\\n * history tracking.\\n * @dev Note that if you feel like a method should be created inside this library, you might want to really consider\\n * whether or not it is the right place for it. Any facet using a method from internal libraries see their bytecode\\n * size increase, kind of defeating the benefits of using facets in the first place. So please keep it reasonable.\\n */\\nlibrary LibFastHistory {\\n  /// @notice The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  /// @notice This is keccak256('Fast.storage.History'):\\n  bytes32 internal constant STORAGE_SLOT = 0x6bc8b61a9dd5fc049ea98027492a801d74e35fdf4d80d7fecd551a16e88fdbb4;\\n\\n  // Storage structures.\\n\\n  /**\\n   * @notice The history data structure required for operating any given FAST diamond.\\n   * @dev The `version` field is used to ensure that storage is at a known version during upgrades.\\n   */\\n  struct Data {\\n    /// @notice The latest intializer version that was called.\\n    uint16 version;\\n    /// @notice All minting proofs are kept here.\\n    SupplyProof[] supplyProofs;\\n    /// @notice All transfer proofs are kept here.\\n    TransferProof[] transferProofs;\\n    /// @notice All transfers indices involving a given address are kept here.\\n    mapping(address => uint256[]) transferProofInvolvements;\\n  }\\n\\n  // Other structures.\\n\\n  /// @notice A minting operation could either be to mint or burn tokens.\\n  enum SupplyOp {\\n    Mint,\\n    Burn\\n  }\\n\\n  /// @notice Minting operations are recorded for papertrail. This is the structure that keeps track of them.\\n  struct SupplyProof {\\n    /// @notice How...\\n    SupplyOp op;\\n    /// @notice How much...\\n    uint256 amount;\\n    /// @notice When...\\n    uint256 blockNumber;\\n    /// @notice Why...\\n    string ref;\\n  }\\n\\n  /// @notice Every transfer in is recorded. This is the structure that keeps track of them.\\n  struct TransferProof {\\n    /// @notice Who spent...\\n    address spender;\\n    /// @notice Who performed the transfer...\\n    address from;\\n    /// @notice Who received...\\n    address to;\\n    /// @notice How much...\\n    uint256 amount;\\n    /// @notice When...\\n    uint256 blockNumber;\\n    /// @notice Why...\\n    string ref;\\n  }\\n\\n  /**\\n   * @notice Returns the history storage for the calling FAST.\\n   * @return s a struct pointer for history FAST data storage.\\n   */\\n  function data() internal pure returns (Data storage s) {\\n    assembly {\\n      s.slot := STORAGE_SLOT\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x21e2cb01ca5bc6109080cd9695296e4ae346a2936c8cae3b3c0b68cef9a90a5e\",\"license\":\"MIT\"},\"contracts/interfaces/ICustomErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\ninterface ICustomErrors {\\n  error AlreadyInitialized();\\n  error CannotSelfRemove(address who);\\n  error DuplicateEntry();\\n  error InconsistentParameter(string param);\\n  error InsufficientFunds(uint256 amount);\\n  error InterfaceNotSupported(string);\\n  error InternalMethod();\\n  error InvalidCrowdfundBasisPointsFee(uint32 fee);\\n  error InvalidPhase();\\n  error NonExistentEntry();\\n  error OutOfBounds();\\n  error Overfunded(uint256 amount);\\n  error ReentrancyError();\\n  error RequiresAutomatonsManager(address who);\\n  error RequiresContinuousSupply();\\n  error RequiresDiamondOwnership(address who);\\n  error RequiresDifferentSenderAndRecipient(address a);\\n  error RequiresFastCaller();\\n  error RequiresFastContractCaller();\\n  error RequiresFastGovernorship(address who);\\n  error RequiresFastMemberCaller();\\n  error RequiresFastMembership(address who);\\n  error RequiresGovernorsManager(address who);\\n  error RequiresIssuerMemberCaller();\\n  error RequiresIssuerMemberOrIssuerCaller();\\n  error RequiresIssuerMembership(address who);\\n  error RequiresManagerCaller();\\n  error RequiresMarketplaceActiveMembership(address who);\\n  error RequiresMarketplaceDeactivatedMember(address who);\\n  error RequiresMarketplaceMembership(address who);\\n  error RequiresMembersManager(address who);\\n  error RequiresNoFastMemberships(address who);\\n  error RequiresOwner(address who);\\n  error RequiresPositiveBalance(address holder);\\n  error RequiresTransfersEnabled();\\n  error RequiresValidGovernor(address who);\\n  error RequiresValidMember(address who);\\n  error RequiresValidTokenHolder(address who);\\n  error TokenContractError();\\n  error UnknownBeneficiary(address who);\\n  error UnknownPledger(address who);\\n  error UnsupportedOperation();\\n}\\n\",\"keccak256\":\"0xd6da7364331de0a387574a44c5a4e7555b63cfe4baaca4dfef42c5d2345f0683\",\"license\":\"MIT\"},\"contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\n// Directly import IERC165 from OpenZeppelin contracts.\\n// Solves an issue with 2 conflicting definitions of IERC165.\\nimport {IERC165} from \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\n\",\"keccak256\":\"0x4d40fa89830d0f833aacefdbab507408a29b692e37990192c6b5e4ce581db830\",\"license\":\"MIT\"},\"contracts/interfaces/IERC173.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\n/**\\n * @title ERC173 Contract Ownership Standard\\n * @dev The ERC165 identifier for this interface is 0x7f5828d0.\\n */\\ninterface IERC173 {\\n  /// @notice This emits when ownership of a contract changes.\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  /// @notice Get the address of the owner\\n  /// @return owner_ The address of the owner.\\n  function owner() external view returns (address owner_);\\n\\n  /// @notice Set the address of the new owner of the contract\\n  /// @notice Set _newOwner to address(0) to renounce any ownership.\\n  /// @param _newOwner The address of the new owner of the contract\\n  function transferOwnership(address _newOwner) external;\\n}\\n\",\"keccak256\":\"0x797855e7870ec3c9f32dda93166bd12dc19fec66cc9a8a7a58f03339a31439c0\",\"license\":\"MIT\"},\"contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/interfaces/IERC20.sol\\\";\\n\",\"keccak256\":\"0x8af6e7ffd7a4cbae707b539d4271f8a3e36e373ea1470706fe368b7e6e6c33f7\",\"license\":\"MIT\"},\"contracts/interfaces/IHasActiveMembers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\n/// @title An interface signifying that the inheriting contract implements the concept of active memberships.\\ninterface IHasActiveMembers {\\n  /**\\n   * @notice Queries whether a given account is a member of the marketplace and flagged as active.\\n   * @param member is the address to query.\\n   * @return A `bool` set to `true` if the candidate is an active member.\\n   */\\n  function isActiveMember(address member) external view returns (bool);\\n\\n  /**\\n   * @notice Deactivates a given member address.\\n   * @param member is the address to deactivate.\\n   */\\n  function deactivateMember(address member) external;\\n\\n  /**\\n   * @notice Activates a given member address.\\n   * @param member is the address to activate.\\n   */\\n  function activateMember(address member) external;\\n}\\n\",\"keccak256\":\"0x0958282b7db89cef8026f5e57b870ed8bf4b0c59b197d44f3154261cc4eb6fd8\",\"license\":\"MIT\"},\"contracts/lib/LibAddressSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nlibrary LibAddressSet {\\n  /// @notice Represents a list of addresses.\\n  struct Data {\\n    mapping(address => uint256) indices;\\n    address[] values;\\n  }\\n\\n  /**\\n   * @notice Adds an item into the storage set. If the address already exists in the set, the method reverts.\\n   * @param d is the internal data storage to use.\\n   * @param key is the address to be added.\\n   */\\n  function add(Data storage d, address key, bool noThrow) internal {\\n    bool exists = contains(d, key);\\n    if (noThrow && exists) {\\n      return;\\n    }\\n    require(!exists, \\\"Address already in set\\\");\\n    d.indices[key] = d.values.length;\\n    d.values.push(key);\\n  }\\n\\n  /**\\n   * @notice Removes an item from the storage set. If the address does not exist in the set, the method reverts.\\n   * @param d is the internal data storage to use.\\n   * @param key is the address to be removed.\\n   */\\n  function remove(Data storage d, address key, bool noThrow) internal {\\n    bool exists = contains(d, key);\\n    if (noThrow && !exists) {\\n      return;\\n    }\\n    require(exists, \\\"Address does not exist in set\\\");\\n    address keyToMove = d.values[d.values.length - 1];\\n    uint256 idxToReplace = d.indices[key];\\n    d.indices[keyToMove] = idxToReplace;\\n    d.values[idxToReplace] = keyToMove;\\n\\n    delete d.indices[key];\\n    d.values.pop();\\n  }\\n\\n  /**\\n   * @notice Tests whether or not a given item already exists in the set.\\n   * @param d is the internal data storage to use.\\n   * @param key is the address to test.\\n   * @return a boolean.\\n   */\\n  function contains(Data storage d, address key) internal view returns (bool) {\\n    return d.values.length == 0 ? false : d.values[d.indices[key]] == key;\\n  }\\n}\\n\",\"keccak256\":\"0x47c911c8b83ffd42c9d6088104f3c2c5eac2899fdf200b3683d1de10ca96b1a8\",\"license\":\"MIT\"},\"contracts/lib/LibHelpers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport \\\"./LibHelpers.sol\\\";\\nimport \\\"../interfaces/IERC173.sol\\\";\\n\\nlibrary LibHelpers {\\n  address internal constant ZERO_ADDRESS = address(0);\\n  address internal constant DEPLOYER_CONTRACT = 0x6DF2D25d8C6FD680730ee658b530A05a99BB769a;\\n  // SEE: https://github.com/safe-global/safe-singleton-factory\\n  address internal constant DEPLOYER_CONTRACT_EIP155 = 0x914d7Fec6aaC8cd542e72Bca78B30650d45643d7;\\n\\n  function _isDiamondFacet(address who) internal view returns (bool) {\\n    return who == address(this);\\n  }\\n\\n  function _isDiamondOwner(address who) internal view returns (bool) {\\n    return who == IERC173(address(this)).owner();\\n  }\\n\\n  function _isDeployer(address who) internal pure returns (bool) {\\n    return (who == LibHelpers.DEPLOYER_CONTRACT) || (who == LibHelpers.DEPLOYER_CONTRACT_EIP155);\\n  }\\n}\\n\",\"keccak256\":\"0xf766b51c66d2f42625cbed10d6e17c65fbe0e38b8cadeac64bcc105fc9cf60d1\",\"license\":\"MIT\"},\"contracts/lib/LibPaginate.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport \\\"../fast/lib/LibFastHistory.sol\\\";\\n\\nlibrary LibPaginate {\\n  function addresses(\\n    address[] storage collection,\\n    uint256 cursor,\\n    uint256 perPage\\n  ) internal view returns (address[] memory, uint256) {\\n    uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n    address[] memory values = new address[](length);\\n    for (uint256 i = 0; i < length; ) {\\n      values[i] = collection[cursor + i];\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n    return (values, cursor + length);\\n  }\\n\\n  function uint256s(\\n    uint256[] storage collection,\\n    uint256 cursor,\\n    uint256 perPage\\n  ) internal view returns (uint256[] memory, uint256) {\\n    uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n    uint256[] memory values = new uint256[](length);\\n    for (uint256 i = 0; i < length; ) {\\n      values[i] = collection[cursor + i];\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n    return (values, cursor + length);\\n  }\\n\\n  function supplyProofs(\\n    LibFastHistory.SupplyProof[] storage collection,\\n    uint256 cursor,\\n    uint256 perPage\\n  ) internal view returns (LibFastHistory.SupplyProof[] memory, uint256) {\\n    uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n    LibFastHistory.SupplyProof[] memory values = new LibFastHistory.SupplyProof[](length);\\n    for (uint256 i = 0; i < length; ) {\\n      values[i] = collection[cursor + i];\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n    return (values, cursor + length);\\n  }\\n\\n  function transferProofs(\\n    LibFastHistory.TransferProof[] storage collection,\\n    uint256 cursor,\\n    uint256 perPage\\n  ) internal view returns (LibFastHistory.TransferProof[] memory, uint256) {\\n    uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n    LibFastHistory.TransferProof[] memory values = new LibFastHistory.TransferProof[](length);\\n    for (uint256 i = 0; i < length; ) {\\n      values[i] = collection[cursor + i];\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n    return (values, cursor + length);\\n  }\\n}\\n\",\"keccak256\":\"0xf2f7e33b965e27fa953f0b95922856f42b2563f9a037a17e1973af5a496899ca\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610483806100206000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063572b6c0514610046578063ce1b815f146100af578063da74222814610112575b600080fd5b61009a6100543660046103ee565b7fa9930c2ffa1b605b0243ba36b3020146bcba5a29c05a711f5ca7c705a8e851ca5462010000900473ffffffffffffffffffffffffffffffffffffffff90811691161490565b60405190151581526020015b60405180910390f35b7fa9930c2ffa1b605b0243ba36b3020146bcba5a29c05a711f5ca7c705a8e851ca5462010000900473ffffffffffffffffffffffffffffffffffffffff1660405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100a6565b6101256101203660046103ee565b610127565b005b61013033610321565b61016d576040517fe88af4e30000000000000000000000000000000000000000000000000000000081523360048201526024015b60405180910390fd5b6040517f01ffc9a70000000000000000000000000000000000000000000000000000000081527f25e23e6400000000000000000000000000000000000000000000000000000000600482015273ffffffffffffffffffffffffffffffffffffffff8216906301ffc9a790602401602060405180830381865afa1580156101f7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061021b919061042b565b610281576040517f216bf93000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f49466f72776172646572000000000000000000000000000000000000000000006044820152606401610164565b7fa9930c2ffa1b605b0243ba36b3020146bcba5a29c05a711f5ca7c705a8e851ca805473ffffffffffffffffffffffffffffffffffffffff83166201000081027fffffffffffffffffffff0000000000000000000000000000000000000000ffff90921691909117825560408051918252517f9ecfd97bf22760e90779a4364f3646d6cbb7e6207b75280c803ca569a34234a09181900360200190a15050565b600061032c82610332565b92915050565b60007f80c187ea6f955fd624c41fb7a18011cc87d98c6f4c06d897b59142f65707e705546040517fa230c52400000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8481166004830152620100009092049091169063a230c52490602401602060405180830381865afa1580156103ca573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061032c919061042b565b60006020828403121561040057600080fd5b813573ffffffffffffffffffffffffffffffffffffffff8116811461042457600080fd5b9392505050565b60006020828403121561043d57600080fd5b8151801515811461042457600080fdfea26469706673582212201b3ade77c2a2f11f946c6a49056f1384da7bb1d6f1e5ad61977c23de7bf9d40964736f6c634300080a0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100415760003560e01c8063572b6c0514610046578063ce1b815f146100af578063da74222814610112575b600080fd5b61009a6100543660046103ee565b7fa9930c2ffa1b605b0243ba36b3020146bcba5a29c05a711f5ca7c705a8e851ca5462010000900473ffffffffffffffffffffffffffffffffffffffff90811691161490565b60405190151581526020015b60405180910390f35b7fa9930c2ffa1b605b0243ba36b3020146bcba5a29c05a711f5ca7c705a8e851ca5462010000900473ffffffffffffffffffffffffffffffffffffffff1660405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100a6565b6101256101203660046103ee565b610127565b005b61013033610321565b61016d576040517fe88af4e30000000000000000000000000000000000000000000000000000000081523360048201526024015b60405180910390fd5b6040517f01ffc9a70000000000000000000000000000000000000000000000000000000081527f25e23e6400000000000000000000000000000000000000000000000000000000600482015273ffffffffffffffffffffffffffffffffffffffff8216906301ffc9a790602401602060405180830381865afa1580156101f7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061021b919061042b565b610281576040517f216bf93000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f49466f72776172646572000000000000000000000000000000000000000000006044820152606401610164565b7fa9930c2ffa1b605b0243ba36b3020146bcba5a29c05a711f5ca7c705a8e851ca805473ffffffffffffffffffffffffffffffffffffffff83166201000081027fffffffffffffffffffff0000000000000000000000000000000000000000ffff90921691909117825560408051918252517f9ecfd97bf22760e90779a4364f3646d6cbb7e6207b75280c803ca569a34234a09181900360200190a15050565b600061032c82610332565b92915050565b60007f80c187ea6f955fd624c41fb7a18011cc87d98c6f4c06d897b59142f65707e705546040517fa230c52400000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8481166004830152620100009092049091169063a230c52490602401602060405180830381865afa1580156103ca573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061032c919061042b565b60006020828403121561040057600080fd5b813573ffffffffffffffffffffffffffffffffffffffff8116811461042457600080fd5b9392505050565b60006020828403121561043d57600080fd5b8151801515811461042457600080fdfea26469706673582212201b3ade77c2a2f11f946c6a49056f1384da7bb1d6f1e5ad61977c23de7bf9d40964736f6c634300080a0033",
  "devdoc": {
    "errors": {
      "RequiresForwarderManager(address)": [
        {
          "params": {
            "who": "is the address that called the function."
          }
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "getTrustedForwarder()": {
        "returns": {
          "forwarderAddress": "The address of the Forwarder contract that is being used."
        }
      },
      "isTrustedForwarder(address)": {
        "params": {
          "_forwarderAddress": "the forwarder address."
        },
        "returns": {
          "_0": "bool if the forwarder is trusted."
        }
      },
      "setTrustedForwarder(address)": {
        "params": {
          "_forwarderAddress": "the forwarder address."
        }
      }
    },
    "title": "The Fast forwardable contract.",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "RequiresForwarderManager(address)": [
        {
          "notice": "Happens when a function is called by a non forwarder manager."
        }
      ]
    },
    "events": {
      "Burnt(uint256,string,address)": {
        "notice": "Emited whenever an burning happens in a FAST."
      },
      "CrowdfundDeployed(address)": {
        "notice": "Crowdfund related events."
      },
      "DetailsChanged(bool,uint32,uint256,uint256,uint256,uint256)": {
        "notice": "This is an event that is fired whenever any of some of the FAST parameters change, so that the frontend can react to it and refresh the general header for that fast as well as the baseball cards in the FASTs list."
      },
      "Disapproval(address,address,uint256)": {
        "notice": "See `ERC20.Disapproval`."
      },
      "DistributionDeployed(address)": {
        "notice": "Distribution related events."
      },
      "FastTransfer(address,address,address,uint256,string)": {
        "notice": "As we augmented the ERC20 standard with a few concepts, we emit our custom events in addition to the ERC20 ones."
      },
      "ForwarderChanged(address)": {
        "notice": "Emited when a forwarder is set on an implementing contract."
      },
      "Minted(uint256,string,address)": {
        "notice": "Emited whenever an issuance happens in a FAST."
      }
    },
    "kind": "user",
    "methods": {
      "getTrustedForwarder()": {
        "notice": "WARNING: The Forwarder can have a full control over your Recipient. Only trust verified Forwarder.Method is not a required method to allow Recipients to trust multiple Forwarders. Not recommended yet."
      },
      "isTrustedForwarder(address)": {
        "notice": "ERC2771Recipient implementation."
      },
      "setTrustedForwarder(address)": {
        "notice": "ERC2771Recipient implementation."
      }
    },
    "notice": "The Fast Forwardable facet is in charge of \"gasless transactions\".",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}